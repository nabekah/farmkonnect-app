import { EventEmitter } from 'events';\n\nexport type DataSourceType = 'api' | 'database' | 'cache' | 'computed' | 'webhook';\nexport type DataRefreshMode = 'manual' | 'interval' | 'realtime' | 'on-demand';\n\nexport interface DataSourceConfig {\n  id: string;\n  name: string;\n  type: DataSourceType;\n  endpoint?: string;\n  query?: string;\n  refreshMode: DataRefreshMode;\n  refreshInterval?: number; // milliseconds\n  cacheEnabled: boolean;\n  cacheTTL?: number; // milliseconds\n  authentication?: {\n    type: 'none' | 'bearer' | 'api-key' | 'basic';\n    credentials?: Record<string, string>;\n  };\n  transformations?: Array<{\n    type: 'filter' | 'map' | 'aggregate' | 'sort';\n    config: Record<string, any>;\n  }>;\n  errorHandling: {\n    retryOnFailure: boolean;\n    maxRetries: number;\n    fallbackValue?: any;\n  };\n  createdAt: number;\n  updatedAt: number;\n}\n\nexport interface DataSourceData {\n  id: string;\n  sourceId: string;\n  data: any;\n  fetchedAt: number;\n  status: 'success' | 'error' | 'stale';\n  error?: string;\n  cacheHit: boolean;\n}\n\nexport interface WidgetDataBinding {\n  widgetId: string;\n  sourceId: string;\n  fieldMappings: Record<string, string>; // widget field -> source field\n  refreshSync: boolean; // sync refresh with widget\n}\n\nexport class WidgetDataSourceManager extends EventEmitter {\n  private dataSources: Map<string, DataSourceConfig> = new Map();\n  private cachedData: Map<string, DataSourceData> = new Map();\n  private bindings: Map<string, WidgetDataBinding> = new Map();\n  private refreshTimers: Map<string, NodeJS.Timeout> = new Map();\n  private sourceCounter = 0;\n  private bindingCounter = 0;\n\n  /**\n   * Register a data source\n   */\n  registerDataSource(config: Omit<DataSourceConfig, 'id' | 'createdAt' | 'updatedAt'>): DataSourceConfig {\n    const sourceId = `source-${++this.sourceCounter}`;\n    const dataSource: DataSourceConfig = {\n      ...config,\n      id: sourceId,\n      createdAt: Date.now(),\n      updatedAt: Date.now(),\n    };\n\n    this.dataSources.set(sourceId, dataSource);\n\n    // Start refresh if needed\n    if (config.refreshMode === 'interval' && config.refreshInterval) {\n      this.startIntervalRefresh(sourceId);\n    }\n\n    this.emit('source:registered', dataSource);\n    return dataSource;\n  }\n\n  /**\n   * Update data source configuration\n   */\n  updateDataSource(sourceId: string, updates: Partial<DataSourceConfig>): DataSourceConfig | null {\n    const source = this.dataSources.get(sourceId);\n    if (!source) return null;\n\n    // Stop existing timer if refresh mode changed\n    if (updates.refreshMode !== source.refreshMode) {\n      this.stopRefresh(sourceId);\n    }\n\n    const updated: DataSourceConfig = {\n      ...source,\n      ...updates,\n      id: source.id,\n      createdAt: source.createdAt,\n      updatedAt: Date.now(),\n    };\n\n    this.dataSources.set(sourceId, updated);\n\n    // Start new refresh if needed\n    if (updated.refreshMode === 'interval' && updated.refreshInterval) {\n      this.startIntervalRefresh(sourceId);\n    }\n\n    this.emit('source:updated', updated);\n    return updated;\n  }\n\n  /**\n   * Remove data source\n   */\n  removeDataSource(sourceId: string): boolean {\n    const source = this.dataSources.get(sourceId);\n    if (!source) return false;\n\n    this.stopRefresh(sourceId);\n    this.dataSources.delete(sourceId);\n    this.cachedData.delete(sourceId);\n\n    // Remove bindings\n    const bindingsToRemove = Array.from(this.bindings.values()).filter((b) => b.sourceId === sourceId);\n    bindingsToRemove.forEach((b) => this.bindings.delete(b.widgetId));\n\n    this.emit('source:removed', source);\n    return true;\n  }\n\n  /**\n   * Fetch data from source\n   */\n  async fetchData(sourceId: string, forceRefresh = false): Promise<DataSourceData> {\n    const source = this.dataSources.get(sourceId);\n    if (!source) {\n      throw new Error(`Data source ${sourceId} not found`);\n    }\n\n    // Check cache first\n    if (!forceRefresh && source.cacheEnabled) {\n      const cached = this.cachedData.get(sourceId);\n      if (cached && this.isCacheValid(cached, source.cacheTTL)) {\n        this.emit('data:fetched', { ...cached, cacheHit: true });\n        return { ...cached, cacheHit: true };\n      }\n    }\n\n    try {\n      let data: any;\n\n      // Fetch based on source type\n      switch (source.type) {\n        case 'api':\n          data = await this.fetchFromAPI(source);\n          break;\n        case 'database':\n          data = await this.fetchFromDatabase(source);\n          break;\n        case 'cache':\n          data = await this.fetchFromCache(source);\n          break;\n        case 'computed':\n          data = await this.computeData(source);\n          break;\n        case 'webhook':\n          data = await this.fetchFromWebhook(source);\n          break;\n      }\n\n      // Apply transformations\n      if (source.transformations && source.transformations.length > 0) {\n        data = this.applyTransformations(data, source.transformations);\n      }\n\n      const result: DataSourceData = {\n        id: `data-${Date.now()}`,\n        sourceId,\n        data,\n        fetchedAt: Date.now(),\n        status: 'success',\n        cacheHit: false,\n      };\n\n      // Cache if enabled\n      if (source.cacheEnabled) {\n        this.cachedData.set(sourceId, result);\n      }\n\n      this.emit('data:fetched', result);\n      return result;\n    } catch (error) {\n      const errorData: DataSourceData = {\n        id: `data-${Date.now()}`,\n        sourceId,\n        data: source.errorHandling.fallbackValue,\n        fetchedAt: Date.now(),\n        status: 'error',\n        error: String(error),\n        cacheHit: false,\n      };\n\n      this.emit('data:error', errorData);\n      throw error;\n    }\n  }\n\n  /**\n   * Fetch from API\n   */\n  private async fetchFromAPI(source: DataSourceConfig): Promise<any> {\n    if (!source.endpoint) throw new Error('API endpoint not configured');\n\n    const headers: Record<string, string> = {\n      'Content-Type': 'application/json',\n    };\n\n    if (source.authentication) {\n      if (source.authentication.type === 'bearer') {\n        headers['Authorization'] = `Bearer ${source.authentication.credentials?.token}`;\n      } else if (source.authentication.type === 'api-key') {\n        headers['X-API-Key'] = source.authentication.credentials?.key || '';\n      } else if (source.authentication.type === 'basic') {\n        const creds = `${source.authentication.credentials?.username}:${source.authentication.credentials?.password}`;\n        headers['Authorization'] = `Basic ${Buffer.from(creds).toString('base64')}`;\n      }\n    }\n\n    // Simulate API call\n    return new Promise((resolve) => {\n      setTimeout(() => {\n        resolve({ success: true, data: [] });\n      }, 100);\n    });\n  }\n\n  /**\n   * Fetch from database\n   */\n  private async fetchFromDatabase(source: DataSourceConfig): Promise<any> {\n    if (!source.query) throw new Error('Database query not configured');\n\n    // Simulate database query\n    return new Promise((resolve) => {\n      setTimeout(() => {\n        resolve([]);\n      }, 100);\n    });\n  }\n\n  /**\n   * Fetch from cache\n   */\n  private async fetchFromCache(source: DataSourceConfig): Promise<any> {\n    // Simulate cache fetch\n    return new Promise((resolve) => {\n      setTimeout(() => {\n        resolve({});\n      }, 50);\n    });\n  }\n\n  /**\n   * Compute data\n   */\n  private async computeData(source: DataSourceConfig): Promise<any> {\n    // Simulate computation\n    return new Promise((resolve) => {\n      setTimeout(() => {\n        resolve({ computed: true });\n      }, 100);\n    });\n  }\n\n  /**\n   * Fetch from webhook\n   */\n  private async fetchFromWebhook(source: DataSourceConfig): Promise<any> {\n    // Simulate webhook fetch\n    return new Promise((resolve) => {\n      setTimeout(() => {\n        resolve({ webhook: true });\n      }, 100);\n    });\n  }\n\n  /**\n   * Apply transformations\n   */\n  private applyTransformations(data: any, transformations: DataSourceConfig['transformations']): any {\n    let result = data;\n\n    if (!transformations) return result;\n\n    for (const transform of transformations) {\n      switch (transform.type) {\n        case 'filter':\n          if (Array.isArray(result)) {\n            result = result.filter((item) => this.evaluateFilter(item, transform.config));\n          }\n          break;\n        case 'map':\n          if (Array.isArray(result)) {\n            result = result.map((item) => this.mapFields(item, transform.config));\n          }\n          break;\n        case 'aggregate':\n          result = this.aggregateData(result, transform.config);\n          break;\n        case 'sort':\n          if (Array.isArray(result)) {\n            result = result.sort((a, b) => this.compareValues(a, b, transform.config));\n          }\n          break;\n      }\n    }\n\n    return result;\n  }\n\n  /**\n   * Evaluate filter\n   */\n  private evaluateFilter(item: any, config: Record<string, any>): boolean {\n    const { field, operator, value } = config;\n    const itemValue = this.getNestedValue(item, field);\n\n    switch (operator) {\n      case 'eq':\n        return itemValue === value;\n      case 'ne':\n        return itemValue !== value;\n      case 'gt':\n        return itemValue > value;\n      case 'lt':\n        return itemValue < value;\n      case 'gte':\n        return itemValue >= value;\n      case 'lte':\n        return itemValue <= value;\n      case 'in':\n        return Array.isArray(value) && value.includes(itemValue);\n      case 'contains':\n        return String(itemValue).includes(String(value));\n      default:\n        return true;\n    }\n  }\n\n  /**\n   * Map fields\n   */\n  private mapFields(item: any, config: Record<string, string>): any {\n    const result: Record<string, any> = {};\n    for (const [targetField, sourceField] of Object.entries(config)) {\n      result[targetField] = this.getNestedValue(item, sourceField);\n    }\n    return result;\n  }\n\n  /**\n   * Aggregate data\n   */\n  private aggregateData(data: any, config: Record<string, any>): any {\n    if (!Array.isArray(data)) return data;\n\n    const { type, field } = config;\n    const values = data.map((item) => this.getNestedValue(item, field)).filter((v) => v !== null);\n\n    switch (type) {\n      case 'sum':\n        return values.reduce((a, b) => a + b, 0);\n      case 'avg':\n        return values.length > 0 ? values.reduce((a, b) => a + b, 0) / values.length : 0;\n      case 'min':\n        return Math.min(...values);\n      case 'max':\n        return Math.max(...values);\n      case 'count':\n        return values.length;\n      default:\n        return data;\n    }\n  }\n\n  /**\n   * Compare values for sorting\n   */\n  private compareValues(a: any, b: any, config: Record<string, any>): number {\n    const { field, order } = config;\n    const aVal = this.getNestedValue(a, field);\n    const bVal = this.getNestedValue(b, field);\n\n    if (aVal < bVal) return order === 'asc' ? -1 : 1;\n    if (aVal > bVal) return order === 'asc' ? 1 : -1;\n    return 0;\n  }\n\n  /**\n   * Get nested value from object\n   */\n  private getNestedValue(obj: any, path: string): any {\n    return path.split('.').reduce((current, prop) => current?.[prop], obj);\n  }\n\n  /**\n   * Check if cache is valid\n   */\n  private isCacheValid(data: DataSourceData, ttl?: number): boolean {\n    if (!ttl) return true;\n    return Date.now() - data.fetchedAt < ttl;\n  }\n\n  /**\n   * Start interval refresh\n   */\n  private startIntervalRefresh(sourceId: string) {\n    const source = this.dataSources.get(sourceId);\n    if (!source || !source.refreshInterval) return;\n\n    this.stopRefresh(sourceId);\n\n    const timer = setInterval(() => {\n      this.fetchData(sourceId, true).catch((error) => {\n        this.emit('refresh:error', { sourceId, error });\n      });\n    }, source.refreshInterval);\n\n    this.refreshTimers.set(sourceId, timer);\n  }\n\n  /**\n   * Stop refresh\n   */\n  private stopRefresh(sourceId: string) {\n    const timer = this.refreshTimers.get(sourceId);\n    if (timer) {\n      clearInterval(timer);\n      this.refreshTimers.delete(sourceId);\n    }\n  }\n\n  /**\n   * Bind widget to data source\n   */\n  bindWidgetToSource(\n    widgetId: string,\n    sourceId: string,\n    fieldMappings: Record<string, string>,\n    refreshSync = true\n  ): WidgetDataBinding {\n    const binding: WidgetDataBinding = {\n      widgetId,\n      sourceId,\n      fieldMappings,\n      refreshSync,\n    };\n\n    this.bindings.set(widgetId, binding);\n    this.emit('binding:created', binding);\n\n    return binding;\n  }\n\n  /**\n   * Get binding for widget\n   */\n  getBinding(widgetId: string): WidgetDataBinding | undefined {\n    return this.bindings.get(widgetId);\n  }\n\n  /**\n   * Get all data sources\n   */\n  getAllDataSources(): DataSourceConfig[] {\n    return Array.from(this.dataSources.values());\n  }\n\n  /**\n   * Get data source by ID\n   */\n  getDataSource(sourceId: string): DataSourceConfig | undefined {\n    return this.dataSources.get(sourceId);\n  }\n\n  /**\n   * Get statistics\n   */\n  getStatistics() {\n    const sources = Array.from(this.dataSources.values());\n    const cachedItems = Array.from(this.cachedData.values());\n\n    return {\n      totalSources: sources.length,\n      sourcesByType: {\n        api: sources.filter((s) => s.type === 'api').length,\n        database: sources.filter((s) => s.type === 'database').length,\n        cache: sources.filter((s) => s.type === 'cache').length,\n        computed: sources.filter((s) => s.type === 'computed').length,\n        webhook: sources.filter((s) => s.type === 'webhook').length,\n      },\n      totalBindings: this.bindings.size,\n      cachedItems: cachedItems.length,\n      successfulFetches: cachedItems.filter((d) => d.status === 'success').length,\n      failedFetches: cachedItems.filter((d) => d.status === 'error').length,\n    };\n  }\n\n  /**\n   * Cleanup\n   */\n  destroy() {\n    this.refreshTimers.forEach((timer) => clearInterval(timer));\n    this.refreshTimers.clear();\n    this.dataSources.clear();\n    this.cachedData.clear();\n    this.bindings.clear();\n  }\n}\n
