import { EventEmitter } from 'events';\n\nexport interface CollaborationUser {\n  userId: string;\n  name: string;\n  color: string;\n  cursor?: { x: number; y: number };\n  lastSeen: number;\n}\n\nexport interface TaskUpdate {\n  taskId: string;\n  field: string;\n  oldValue: any;\n  newValue: any;\n  updatedBy: string;\n  timestamp: number;\n}\n\nexport interface CollaborationEvent {\n  type: 'cursor' | 'task-update' | 'comment' | 'user-join' | 'user-leave' | 'presence';\n  userId: string;\n  data: any;\n  timestamp: number;\n}\n\nexport interface PresenceData {\n  userId: string;\n  farmId: string;\n  taskId?: string;\n  status: 'active' | 'idle' | 'away';\n  lastActivity: number;\n}\n\n/**\n * Real-time Collaboration Manager\n */\nexport class RealtimeCollaborationManager extends EventEmitter {\n  private activeUsers: Map<string, CollaborationUser> = new Map();\n  private taskUpdates: Map<string, TaskUpdate[]> = new Map();\n  private presenceData: Map<string, PresenceData> = new Map();\n  private cursorPositions: Map<string, { x: number; y: number }> = new Map();\n  private taskLocks: Map<string, { userId: string; timestamp: number }> = new Map();\n  private lockTimeout = 30000; // 30 seconds\n\n  constructor() {\n    super();\n    this.startPresenceMonitoring();\n  }\n\n  /**\n   * User joins collaboration session\n   */\n  userJoin(userId: string, farmId: string, name: string): CollaborationUser {\n    const color = this.generateUserColor(userId);\n    const user: CollaborationUser = {\n      userId,\n      name,\n      color,\n      lastSeen: Date.now(),\n    };\n\n    this.activeUsers.set(userId, user);\n    this.presenceData.set(userId, {\n      userId,\n      farmId,\n      status: 'active',\n      lastActivity: Date.now(),\n    });\n\n    this.emit('user:joined', { userId, name, farmId });\n    return user;\n  }\n\n  /**\n   * User leaves collaboration session\n   */\n  userLeave(userId: string): boolean {\n    const removed = this.activeUsers.delete(userId);\n    this.presenceData.delete(userId);\n    this.cursorPositions.delete(userId);\n\n    if (removed) {\n      this.emit('user:left', { userId });\n    }\n    return removed;\n  }\n\n  /**\n   * Update cursor position\n   */\n  updateCursor(userId: string, x: number, y: number): void {\n    const user = this.activeUsers.get(userId);\n    if (!user) return;\n\n    user.cursor = { x, y };\n    this.cursorPositions.set(userId, { x, y });\n\n    const presence = this.presenceData.get(userId);\n    if (presence) {\n      presence.lastActivity = Date.now();\n      presence.status = 'active';\n    }\n\n    this.emit('cursor:updated', {\n      userId,\n      cursor: { x, y },\n      color: user.color,\n    });\n  }\n\n  /**\n   * Broadcast task update\n   */\n  broadcastTaskUpdate(\n    taskId: string,\n    field: string,\n    oldValue: any,\n    newValue: any,\n    updatedBy: string\n  ): TaskUpdate {\n    const update: TaskUpdate = {\n      taskId,\n      field,\n      oldValue,\n      newValue,\n      updatedBy,\n      timestamp: Date.now(),\n    };\n\n    if (!this.taskUpdates.has(taskId)) {\n      this.taskUpdates.set(taskId, []);\n    }\n    this.taskUpdates.get(taskId)!.push(update);\n\n    this.emit('task:updated', update);\n    return update;\n  }\n\n  /**\n   * Lock task for editing\n   */\n  lockTask(taskId: string, userId: string): boolean {\n    const existingLock = this.taskLocks.get(taskId);\n    if (existingLock && existingLock.userId !== userId) {\n      const lockAge = Date.now() - existingLock.timestamp;\n      if (lockAge < this.lockTimeout) {\n        return false; // Task is locked by another user\n      }\n    }\n\n    this.taskLocks.set(taskId, { userId, timestamp: Date.now() });\n    this.emit('task:locked', { taskId, userId });\n    return true;\n  }\n\n  /**\n   * Unlock task\n   */\n  unlockTask(taskId: string, userId: string): boolean {\n    const lock = this.taskLocks.get(taskId);\n    if (!lock || lock.userId !== userId) {\n      return false;\n    }\n\n    this.taskLocks.delete(taskId);\n    this.emit('task:unlocked', { taskId, userId });\n    return true;\n  }\n\n  /**\n   * Get task lock info\n   */\n  getTaskLock(taskId: string): { userId: string; timestamp: number } | null {\n    const lock = this.taskLocks.get(taskId);\n    if (!lock) return null;\n\n    const lockAge = Date.now() - lock.timestamp;\n    if (lockAge > this.lockTimeout) {\n      this.taskLocks.delete(taskId);\n      return null;\n    }\n\n    return lock;\n  }\n\n  /**\n   * Get active users\n   */\n  getActiveUsers(): CollaborationUser[] {\n    return Array.from(this.activeUsers.values());\n  }\n\n  /**\n   * Get user presence\n   */\n  getUserPresence(userId: string): PresenceData | null {\n    return this.presenceData.get(userId) || null;\n  }\n\n  /**\n   * Get all presence data\n   */\n  getAllPresence(): PresenceData[] {\n    return Array.from(this.presenceData.values());\n  }\n\n  /**\n   * Get task updates\n   */\n  getTaskUpdates(taskId: string): TaskUpdate[] {\n    return this.taskUpdates.get(taskId) || [];\n  }\n\n  /**\n   * Get cursor positions\n   */\n  getCursorPositions(): Map<string, { x: number; y: number }> {\n    return this.cursorPositions;\n  }\n\n  /**\n   * Start presence monitoring\n   */\n  private startPresenceMonitoring(): void {\n    setInterval(() => {\n      const now = Date.now();\n      const idleThreshold = 60000; // 1 minute\n      const awayThreshold = 300000; // 5 minutes\n\n      for (const [userId, presence] of this.presenceData) {\n        const inactiveTime = now - presence.lastActivity;\n\n        if (inactiveTime > awayThreshold) {\n          if (presence.status !== 'away') {\n            presence.status = 'away';\n            this.emit('presence:changed', { userId, status: 'away' });\n          }\n        } else if (inactiveTime > idleThreshold) {\n          if (presence.status !== 'idle') {\n            presence.status = 'idle';\n            this.emit('presence:changed', { userId, status: 'idle' });\n          }\n        } else {\n          if (presence.status !== 'active') {\n            presence.status = 'active';\n            this.emit('presence:changed', { userId, status: 'active' });\n          }\n        }\n      }\n    }, 30000); // Check every 30 seconds\n  }\n\n  /**\n   * Generate user color\n   */\n  private generateUserColor(userId: string): string {\n    const colors = [\n      '#FF6B6B',\n      '#4ECDC4',\n      '#45B7D1',\n      '#FFA07A',\n      '#98D8C8',\n      '#F7DC6F',\n      '#BB8FCE',\n      '#85C1E2',\n    ];\n    const hash = userId.split('').reduce((acc, char) => acc + char.charCodeAt(0), 0);\n    return colors[hash % colors.length];\n  }\n\n  /**\n   * Get collaboration stats\n   */\n  getCollaborationStats(): {\n    activeUsers: number;\n    totalUpdates: number;\n    lockedTasks: number;\n    averageUpdateRate: number;\n  } {\n    const totalUpdates = Array.from(this.taskUpdates.values()).reduce((sum, updates) => sum + updates.length, 0);\n    const timeWindow = 3600000; // 1 hour\n    const averageUpdateRate = totalUpdates > 0 ? totalUpdates / (timeWindow / 60000) : 0;\n\n    return {\n      activeUsers: this.activeUsers.size,\n      totalUpdates,\n      lockedTasks: this.taskLocks.size,\n      averageUpdateRate: Math.round(averageUpdateRate * 100) / 100,\n    };\n  }\n}\n
