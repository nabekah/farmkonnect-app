import { EventEmitter } from 'events';\nimport { v4 as uuidv4 } from 'uuid';\n\nexport interface TemplateVersion {\n  id: string;\n  templateId: string;\n  version: number;\n  content: Record<string, any>;\n  author: string;\n  message: string;\n  createdAt: number;\n  tags?: string[];\n  isRelease?: boolean;\n}\n\nexport interface TemplateVersionDiff {\n  added: Record<string, any>;\n  removed: Record<string, any>;\n  modified: Record<string, { old: any; new: any }>;\n}\n\nexport interface TemplateVersionMetadata {\n  templateId: string;\n  currentVersion: number;\n  totalVersions: number;\n  lastModified: number;\n  lastModifiedBy: string;\n  isLocked: boolean;\n  lockReason?: string;\n}\n\nexport class TemplateVersioningManager extends EventEmitter {\n  private versions: Map<string, TemplateVersion[]> = new Map();\n  private metadata: Map<string, TemplateVersionMetadata> = new Map();\n  private branches: Map<string, string> = new Map(); // templateId -> branchName -> versionId\n  private tags: Map<string, Set<string>> = new Map(); // templateId -> Set<versionId>\n  private locks: Map<string, { userId: string; reason: string; timestamp: number }> = new Map();\n\n  /**\n   * Create initial version for template\n   */\n  createTemplate(templateId: string, content: Record<string, any>, author: string): TemplateVersion {\n    const version: TemplateVersion = {\n      id: uuidv4(),\n      templateId,\n      version: 1,\n      content: JSON.parse(JSON.stringify(content)),\n      author,\n      message: 'Initial version',\n      createdAt: Date.now(),\n      isRelease: false,\n    };\n\n    if (!this.versions.has(templateId)) {\n      this.versions.set(templateId, []);\n    }\n\n    this.versions.get(templateId)!.push(version);\n\n    this.metadata.set(templateId, {\n      templateId,\n      currentVersion: 1,\n      totalVersions: 1,\n      lastModified: Date.now(),\n      lastModifiedBy: author,\n      isLocked: false,\n    });\n\n    this.branches.set(`${templateId}:main`, version.id);\n\n    this.emit('version:created', version);\n    return version;\n  }\n\n  /**\n   * Create new version from current\n   */\n  createVersion(\n    templateId: string,\n    content: Record<string, any>,\n    author: string,\n    message: string,\n    tags?: string[]\n  ): TemplateVersion | null {\n    const versions = this.versions.get(templateId);\n    if (!versions || versions.length === 0) return null;\n\n    if (this.isLocked(templateId)) {\n      throw new Error(`Template ${templateId} is locked: ${this.locks.get(templateId)?.reason}`);\n    }\n\n    const lastVersion = versions[versions.length - 1];\n    const newVersion: TemplateVersion = {\n      id: uuidv4(),\n      templateId,\n      version: lastVersion.version + 1,\n      content: JSON.parse(JSON.stringify(content)),\n      author,\n      message,\n      createdAt: Date.now(),\n      tags,\n      isRelease: false,\n    };\n\n    versions.push(newVersion);\n\n    const meta = this.metadata.get(templateId)!;\n    meta.currentVersion = newVersion.version;\n    meta.totalVersions = versions.length;\n    meta.lastModified = Date.now();\n    meta.lastModifiedBy = author;\n\n    if (tags) {\n      if (!this.tags.has(templateId)) {\n        this.tags.set(templateId, new Set());\n      }\n      tags.forEach((tag) => this.tags.get(templateId)!.add(newVersion.id));\n    }\n\n    this.emit('version:created', newVersion);\n    return newVersion;\n  }\n\n  /**\n   * Get specific version\n   */\n  getVersion(templateId: string, versionNumber: number): TemplateVersion | null {\n    const versions = this.versions.get(templateId);\n    if (!versions) return null;\n    return versions.find((v) => v.version === versionNumber) || null;\n  }\n\n  /**\n   * Get current version\n   */\n  getCurrentVersion(templateId: string): TemplateVersion | null {\n    const versions = this.versions.get(templateId);\n    if (!versions || versions.length === 0) return null;\n    return versions[versions.length - 1];\n  }\n\n  /**\n   * Get all versions\n   */\n  getAllVersions(templateId: string): TemplateVersion[] {\n    return this.versions.get(templateId) || [];\n  }\n\n  /**\n   * Rollback to specific version\n   */\n  rollback(templateId: string, versionNumber: number, author: string, reason: string): TemplateVersion | null {\n    const targetVersion = this.getVersion(templateId, versionNumber);\n    if (!targetVersion) return null;\n\n    if (this.isLocked(templateId)) {\n      throw new Error(`Template ${templateId} is locked: ${this.locks.get(templateId)?.reason}`);\n    }\n\n    const newVersion = this.createVersion(\n      templateId,\n      targetVersion.content,\n      author,\n      `Rollback to v${versionNumber}: ${reason}`\n    );\n\n    if (newVersion) {\n      this.emit('version:rolledback', {\n        templateId,\n        fromVersion: versionNumber,\n        toVersion: newVersion.version,\n        author,\n        reason,\n      });\n    }\n\n    return newVersion;\n  }\n\n  /**\n   * Compare two versions\n   */\n  compareVersions(templateId: string, version1: number, version2: number): TemplateVersionDiff | null {\n    const v1 = this.getVersion(templateId, version1);\n    const v2 = this.getVersion(templateId, version2);\n\n    if (!v1 || !v2) return null;\n\n    const diff: TemplateVersionDiff = {\n      added: {},\n      removed: {},\n      modified: {},\n    };\n\n    // Find added and modified keys\n    for (const [key, value] of Object.entries(v2.content)) {\n      if (!(key in v1.content)) {\n        diff.added[key] = value;\n      } else if (JSON.stringify(v1.content[key]) !== JSON.stringify(value)) {\n        diff.modified[key] = {\n          old: v1.content[key],\n          new: value,\n        };\n      }\n    }\n\n    // Find removed keys\n    for (const [key, value] of Object.entries(v1.content)) {\n      if (!(key in v2.content)) {\n        diff.removed[key] = value;\n      }\n    }\n\n    return diff;\n  }\n\n  /**\n   * Create branch from version\n   */\n  createBranch(templateId: string, branchName: string, fromVersion?: number): boolean {\n    const branchKey = `${templateId}:${branchName}`;\n\n    if (this.branches.has(branchKey)) {\n      return false; // Branch already exists\n    }\n\n    let versionId: string;\n    if (fromVersion) {\n      const version = this.getVersion(templateId, fromVersion);\n      if (!version) return false;\n      versionId = version.id;\n    } else {\n      const current = this.getCurrentVersion(templateId);\n      if (!current) return false;\n      versionId = current.id;\n    }\n\n    this.branches.set(branchKey, versionId);\n    this.emit('branch:created', { templateId, branchName, versionId });\n    return true;\n  }\n\n  /**\n   * Get branch version\n   */\n  getBranchVersion(templateId: string, branchName: string): TemplateVersion | null {\n    const branchKey = `${templateId}:${branchName}`;\n    const versionId = this.branches.get(branchKey);\n\n    if (!versionId) return null;\n\n    const versions = this.versions.get(templateId);\n    if (!versions) return null;\n\n    return versions.find((v) => v.id === versionId) || null;\n  }\n\n  /**\n   * Merge branch to main\n   */\n  mergeBranch(\n    templateId: string,\n    branchName: string,\n    author: string,\n    message: string\n  ): TemplateVersion | null {\n    const branchVersion = this.getBranchVersion(templateId, branchName);\n    if (!branchVersion) return null;\n\n    const merged = this.createVersion(\n      templateId,\n      branchVersion.content,\n      author,\n      `Merge branch '${branchName}': ${message}`\n    );\n\n    if (merged) {\n      this.emit('branch:merged', {\n        templateId,\n        branchName,\n        mergedVersion: merged.version,\n        author,\n      });\n    }\n\n    return merged;\n  }\n\n  /**\n   * List all branches\n   */\n  listBranches(templateId: string): string[] {\n    const branches: string[] = [];\n    for (const [key, _] of this.branches) {\n      const [id, name] = key.split(':');\n      if (id === templateId) {\n        branches.push(name);\n      }\n    }\n    return branches;\n  }\n\n  /**\n   * Delete branch\n   */\n  deleteBranch(templateId: string, branchName: string): boolean {\n    if (branchName === 'main') return false; // Cannot delete main branch\n\n    const branchKey = `${templateId}:${branchName}`;\n    const deleted = this.branches.delete(branchKey);\n\n    if (deleted) {\n      this.emit('branch:deleted', { templateId, branchName });\n    }\n\n    return deleted;\n  }\n\n  /**\n   * Tag version as release\n   */\n  tagAsRelease(templateId: string, versionNumber: number): boolean {\n    const version = this.getVersion(templateId, versionNumber);\n    if (!version) return false;\n\n    version.isRelease = true;\n    this.emit('version:tagged', { templateId, versionNumber, tag: 'release' });\n    return true;\n  }\n\n  /**\n   * Lock template for editing\n   */\n  lockTemplate(templateId: string, userId: string, reason: string): boolean {\n    if (this.isLocked(templateId)) return false;\n\n    this.locks.set(templateId, {\n      userId,\n      reason,\n      timestamp: Date.now(),\n    });\n\n    this.emit('template:locked', { templateId, userId, reason });\n    return true;\n  }\n\n  /**\n   * Unlock template\n   */\n  unlockTemplate(templateId: string): boolean {\n    const deleted = this.locks.delete(templateId);\n\n    if (deleted) {\n      this.emit('template:unlocked', { templateId });\n    }\n\n    return deleted;\n  }\n\n  /**\n   * Check if template is locked\n   */\n  isLocked(templateId: string): boolean {\n    return this.locks.has(templateId);\n  }\n\n  /**\n   * Get lock info\n   */\n  getLockInfo(templateId: string): { userId: string; reason: string; timestamp: number } | null {\n    return this.locks.get(templateId) || null;\n  }\n\n  /**\n   * Get version history with pagination\n   */\n  getVersionHistory(\n    templateId: string,\n    limit: number = 10,\n    offset: number = 0\n  ): { versions: TemplateVersion[]; total: number } {\n    const versions = this.versions.get(templateId) || [];\n    const total = versions.length;\n    const paginated = versions.slice(Math.max(0, total - offset - limit), total - offset);\n\n    return {\n      versions: paginated.reverse(),\n      total,\n    };\n  }\n\n  /**\n   * Get metadata\n   */\n  getMetadata(templateId: string): TemplateVersionMetadata | null {\n    return this.metadata.get(templateId) || null;\n  }\n\n  /**\n   * Export version as JSON\n   */\n  exportVersion(templateId: string, versionNumber: number): string | null {\n    const version = this.getVersion(templateId, versionNumber);\n    if (!version) return null;\n\n    return JSON.stringify(version, null, 2);\n  }\n\n  /**\n   * Import version from JSON\n   */\n  importVersion(\n    templateId: string,\n    jsonData: string,\n    author: string,\n    message: string\n  ): TemplateVersion | null {\n    try {\n      const data = JSON.parse(jsonData);\n      return this.createVersion(templateId, data, author, `Imported: ${message}`);\n    } catch (error) {\n      return null;\n    }\n  }\n\n  /**\n   * Get version statistics\n   */\n  getStatistics(templateId: string): {\n    totalVersions: number;\n    releases: number;\n    branches: number;\n    contributors: Set<string>;\n    oldestVersion: number;\n    newestVersion: number;\n  } | null {\n    const versions = this.versions.get(templateId);\n    if (!versions || versions.length === 0) return null;\n\n    const contributors = new Set(versions.map((v) => v.author));\n    const releases = versions.filter((v) => v.isRelease).length;\n    const branches = this.listBranches(templateId).length;\n\n    return {\n      totalVersions: versions.length,\n      releases,\n      branches,\n      contributors,\n      oldestVersion: versions[0].version,\n      newestVersion: versions[versions.length - 1].version,\n    };\n  }\n}\n\nexport default TemplateVersioningManager;\n
