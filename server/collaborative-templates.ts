import { EventEmitter } from 'events';\n\nexport interface TemplateUser {\n  userId: string;\n  username: string;\n  color: string;\n  cursorPosition?: { x: number; y: number };\n  isActive: boolean;\n  joinedAt: number;\n}\n\nexport interface TemplateChange {\n  id: string;\n  userId: string;\n  type: 'create' | 'update' | 'delete' | 'merge' | 'comment';\n  fieldPath: string;\n  oldValue?: any;\n  newValue?: any;\n  timestamp: number;\n  description: string;\n}\n\nexport interface TemplateComment {\n  id: string;\n  userId: string;\n  username: string;\n  content: string;\n  resolvedAt?: number;\n  createdAt: number;\n  replies: TemplateComment[];\n}\n\nexport interface ConflictResolution {\n  fieldPath: string;\n  conflictingChanges: TemplateChange[];\n  resolution: 'keep_local' | 'keep_remote' | 'merge' | 'manual';\n  resolvedValue?: any;\n  resolvedBy: string;\n  resolvedAt: number;\n}\n\nexport interface CollaborativeTemplate {\n  id: string;\n  name: string;\n  content: Record<string, any>;\n  activeUsers: TemplateUser[];\n  changeHistory: TemplateChange[];\n  comments: TemplateComment[];\n  conflicts: ConflictResolution[];\n  lastModifiedBy: string;\n  lastModifiedAt: number;\n  createdBy: string;\n  createdAt: number;\n  isLocked: boolean;\n  lockedBy?: string;\n}\n\nexport interface SyncMessage {\n  type: 'change' | 'cursor' | 'presence' | 'comment' | 'lock' | 'unlock';\n  templateId: string;\n  userId: string;\n  data: any;\n  timestamp: number;\n}\n\nclass CollaborativeTemplateManager extends EventEmitter {\n  private templates: Map<string, CollaborativeTemplate> = new Map();\n  private activeConnections: Map<string, Set<string>> = new Map(); // templateId -> Set<userId>\n  private syncQueue: SyncMessage[] = [];\n  private conflictQueue: ConflictResolution[] = [];\n  private userColors: string[] = [\n    '#FF6B6B',\n    '#4ECDC4',\n    '#45B7D1',\n    '#FFA07A',\n    '#98D8C8',\n    '#F7DC6F',\n    '#BB8FCE',\n    '#85C1E2',\n  ];\n  private nextColorIndex: number = 0;\n\n  /**\n   * Create collaborative template\n   */\n  createTemplate(\n    name: string,\n    content: Record<string, any>,\n    userId: string,\n    username: string\n  ): CollaborativeTemplate {\n    const id = `collab-template-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n\n    const template: CollaborativeTemplate = {\n      id,\n      name,\n      content,\n      activeUsers: [],\n      changeHistory: [],\n      comments: [],\n      conflicts: [],\n      lastModifiedBy: userId,\n      lastModifiedAt: Date.now(),\n      createdBy: userId,\n      createdAt: Date.now(),\n      isLocked: false,\n    };\n\n    this.templates.set(id, template);\n    this.activeConnections.set(id, new Set());\n\n    // Record creation change\n    this.recordChange(id, userId, 'create', 'template', undefined, content, 'Created template');\n\n    this.emit('template:created', template);\n    return template;\n  }\n\n  /**\n   * User joins collaborative editing session\n   */\n  joinSession(templateId: string, userId: string, username: string): TemplateUser | null {\n    const template = this.templates.get(templateId);\n    if (!template) return null;\n\n    if (template.isLocked && template.lockedBy !== userId) {\n      return null;\n    }\n\n    const color = this.userColors[this.nextColorIndex % this.userColors.length];\n    this.nextColorIndex++;\n\n    const user: TemplateUser = {\n      userId,\n      username,\n      color,\n      isActive: true,\n      joinedAt: Date.now(),\n    };\n\n    template.activeUsers.push(user);\n\n    if (!this.activeConnections.has(templateId)) {\n      this.activeConnections.set(templateId, new Set());\n    }\n    this.activeConnections.get(templateId)!.add(userId);\n\n    this.emit('user:joined', { templateId, user });\n    this.broadcastPresence(templateId, 'presence', { type: 'joined', user });\n\n    return user;\n  }\n\n  /**\n   * User leaves collaborative session\n   */\n  leaveSession(templateId: string, userId: string): boolean {\n    const template = this.templates.get(templateId);\n    if (!template) return false;\n\n    template.activeUsers = template.activeUsers.filter((u) => u.userId !== userId);\n    this.activeConnections.get(templateId)?.delete(userId);\n\n    this.emit('user:left', { templateId, userId });\n    this.broadcastPresence(templateId, 'presence', { type: 'left', userId });\n\n    return true;\n  }\n\n  /**\n   * Update template content with conflict detection\n   */\n  updateContent(\n    templateId: string,\n    userId: string,\n    fieldPath: string,\n    newValue: any,\n    description: string\n  ): { success: boolean; conflicts?: ConflictResolution[] } {\n    const template = this.templates.get(templateId);\n    if (!template) return { success: false };\n\n    if (template.isLocked && template.lockedBy !== userId) {\n      return { success: false };\n    }\n\n    // Get old value\n    const oldValue = this.getValueByPath(template.content, fieldPath);\n\n    // Check for conflicts with recent changes\n    const conflicts = this.detectConflicts(template, fieldPath, userId);\n\n    if (conflicts.length > 0) {\n      this.conflictQueue.push(...conflicts);\n      return { success: false, conflicts };\n    }\n\n    // Apply update\n    this.setValueByPath(template.content, fieldPath, newValue);\n    template.lastModifiedBy = userId;\n    template.lastModifiedAt = Date.now();\n\n    // Record change\n    this.recordChange(templateId, userId, 'update', fieldPath, oldValue, newValue, description);\n\n    // Broadcast change\n    this.broadcastChange(templateId, {\n      type: 'change',\n      templateId,\n      userId,\n      data: { fieldPath, oldValue, newValue, description },\n      timestamp: Date.now(),\n    });\n\n    this.emit('content:updated', { templateId, userId, fieldPath, newValue });\n    return { success: true };\n  }\n\n  /**\n   * Detect conflicts in concurrent edits\n   */\n  private detectConflicts(\n    template: CollaborativeTemplate,\n    fieldPath: string,\n    userId: string\n  ): ConflictResolution[] {\n    const conflicts: ConflictResolution[] = [];\n    const recentChanges = template.changeHistory.slice(-10);\n\n    for (const change of recentChanges) {\n      if (\n        change.userId !== userId &&\n        change.fieldPath === fieldPath &&\n        Date.now() - change.timestamp < 5000\n      ) {\n        conflicts.push({\n          fieldPath,\n          conflictingChanges: [change],\n          resolution: 'manual',\n          resolvedBy: '',\n          resolvedAt: Date.now(),\n        });\n      }\n    }\n\n    return conflicts;\n  }\n\n  /**\n   * Resolve conflict\n   */\n  resolveConflict(\n    templateId: string,\n    conflictIndex: number,\n    resolution: 'keep_local' | 'keep_remote' | 'merge',\n    resolvedValue?: any\n  ): boolean {\n    const template = this.templates.get(templateId);\n    if (!template || conflictIndex >= template.conflicts.length) return false;\n\n    const conflict = template.conflicts[conflictIndex];\n    conflict.resolution = resolution;\n    conflict.resolvedValue = resolvedValue;\n    conflict.resolvedAt = Date.now();\n\n    // Apply resolution\n    if (resolvedValue !== undefined) {\n      this.setValueByPath(template.content, conflict.fieldPath, resolvedValue);\n    }\n\n    this.emit('conflict:resolved', { templateId, conflict });\n    return true;\n  }\n\n  /**\n   * Add comment to template\n   */\n  addComment(\n    templateId: string,\n    userId: string,\n    username: string,\n    content: string,\n    parentCommentId?: string\n  ): TemplateComment | null {\n    const template = this.templates.get(templateId);\n    if (!template) return null;\n\n    const comment: TemplateComment = {\n      id: `comment-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,\n      userId,\n      username,\n      content,\n      createdAt: Date.now(),\n      replies: [],\n    };\n\n    if (parentCommentId) {\n      const parent = this.findComment(template.comments, parentCommentId);\n      if (parent) {\n        parent.replies.push(comment);\n      }\n    } else {\n      template.comments.push(comment);\n    }\n\n    this.broadcastChange(templateId, {\n      type: 'comment',\n      templateId,\n      userId,\n      data: comment,\n      timestamp: Date.now(),\n    });\n\n    this.emit('comment:added', { templateId, comment });\n    return comment;\n  }\n\n  /**\n   * Resolve comment\n   */\n  resolveComment(templateId: string, commentId: string): boolean {\n    const template = this.templates.get(templateId);\n    if (!template) return false;\n\n    const comment = this.findComment(template.comments, commentId);\n    if (!comment) return false;\n\n    comment.resolvedAt = Date.now();\n    this.emit('comment:resolved', { templateId, commentId });\n    return true;\n  }\n\n  /**\n   * Update cursor position\n   */\n  updateCursorPosition(\n    templateId: string,\n    userId: string,\n    position: { x: number; y: number }\n  ): void {\n    const template = this.templates.get(templateId);\n    if (!template) return;\n\n    const user = template.activeUsers.find((u) => u.userId === userId);\n    if (user) {\n      user.cursorPosition = position;\n    }\n\n    this.broadcastChange(templateId, {\n      type: 'cursor',\n      templateId,\n      userId,\n      data: { position },\n      timestamp: Date.now(),\n    });\n  }\n\n  /**\n   * Lock template for exclusive editing\n   */\n  lockTemplate(templateId: string, userId: string): boolean {\n    const template = this.templates.get(templateId);\n    if (!template) return false;\n\n    if (template.isLocked && template.lockedBy !== userId) {\n      return false;\n    }\n\n    template.isLocked = true;\n    template.lockedBy = userId;\n\n    this.broadcastChange(templateId, {\n      type: 'lock',\n      templateId,\n      userId,\n      data: { lockedBy: userId },\n      timestamp: Date.now(),\n    });\n\n    this.emit('template:locked', { templateId, userId });\n    return true;\n  }\n\n  /**\n   * Unlock template\n   */\n  unlockTemplate(templateId: string, userId: string): boolean {\n    const template = this.templates.get(templateId);\n    if (!template || template.lockedBy !== userId) return false;\n\n    template.isLocked = false;\n    template.lockedBy = undefined;\n\n    this.broadcastChange(templateId, {\n      type: 'unlock',\n      templateId,\n      userId,\n      data: {},\n      timestamp: Date.now(),\n    });\n\n    this.emit('template:unlocked', { templateId, userId });\n    return true;\n  }\n\n  /**\n   * Merge changes from another user\n   */\n  mergeChanges(\n    templateId: string,\n    userId: string,\n    sourceUserId: string\n  ): { success: boolean; mergedCount: number; conflicts: ConflictResolution[] } {\n    const template = this.templates.get(templateId);\n    if (!template) return { success: false, mergedCount: 0, conflicts: [] };\n\n    const sourceChanges = template.changeHistory.filter((c) => c.userId === sourceUserId);\n    const conflicts: ConflictResolution[] = [];\n    let mergedCount = 0;\n\n    for (const change of sourceChanges) {\n      const conflictingChanges = template.changeHistory.filter(\n        (c) => c.userId !== sourceUserId && c.fieldPath === change.fieldPath\n      );\n\n      if (conflictingChanges.length > 0) {\n        conflicts.push({\n          fieldPath: change.fieldPath,\n          conflictingChanges,\n          resolution: 'manual',\n          resolvedBy: userId,\n          resolvedAt: Date.now(),\n        });\n      } else {\n        // Auto-merge non-conflicting changes\n        this.setValueByPath(template.content, change.fieldPath, change.newValue);\n        mergedCount++;\n      }\n    }\n\n    this.recordChange(templateId, userId, 'merge', 'template', undefined, undefined, `Merged changes from ${sourceUserId}`);\n\n    this.emit('changes:merged', { templateId, userId, sourceUserId, mergedCount, conflicts });\n    return { success: true, mergedCount, conflicts };\n  }\n\n  /**\n   * Get template with all metadata\n   */\n  getTemplate(templateId: string): CollaborativeTemplate | undefined {\n    return this.templates.get(templateId);\n  }\n\n  /**\n   * Get active users for template\n   */\n  getActiveUsers(templateId: string): TemplateUser[] {\n    const template = this.templates.get(templateId);\n    return template?.activeUsers || [];\n  }\n\n  /**\n   * Get change history\n   */\n  getChangeHistory(templateId: string, limit: number = 100): TemplateChange[] {\n    const template = this.templates.get(templateId);\n    if (!template) return [];\n\n    return template.changeHistory.slice(-limit);\n  }\n\n  /**\n   * Get pending conflicts\n   */\n  getPendingConflicts(templateId: string): ConflictResolution[] {\n    const template = this.templates.get(templateId);\n    if (!template) return [];\n\n    return template.conflicts.filter((c) => c.resolution === 'manual');\n  }\n\n  /**\n   * Broadcast change to all users\n   */\n  private broadcastChange(templateId: string, message: SyncMessage): void {\n    this.syncQueue.push(message);\n    this.emit('sync:broadcast', { templateId, message });\n  }\n\n  /**\n   * Broadcast presence update\n   */\n  private broadcastPresence(templateId: string, type: string, data: any): void {\n    this.broadcastChange(templateId, {\n      type: 'presence',\n      templateId,\n      userId: 'system',\n      data,\n      timestamp: Date.now(),\n    });\n  }\n\n  /**\n   * Record change in history\n   */\n  private recordChange(\n    templateId: string,\n    userId: string,\n    type: TemplateChange['type'],\n    fieldPath: string,\n    oldValue: any,\n    newValue: any,\n    description: string\n  ): void {\n    const template = this.templates.get(templateId);\n    if (!template) return;\n\n    const change: TemplateChange = {\n      id: `change-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,\n      userId,\n      type,\n      fieldPath,\n      oldValue,\n      newValue,\n      timestamp: Date.now(),\n      description,\n    };\n\n    template.changeHistory.push(change);\n  }\n\n  /**\n   * Get value by path\n   */\n  private getValueByPath(obj: any, path: string): any {\n    return path.split('.').reduce((current, prop) => current?.[prop], obj);\n  }\n\n  /**\n   * Set value by path\n   */\n  private setValueByPath(obj: any, path: string, value: any): void {\n    const parts = path.split('.');\n    const lastPart = parts.pop();\n    if (!lastPart) return;\n\n    let current = obj;\n    for (const part of parts) {\n      if (!current[part]) {\n        current[part] = {};\n      }\n      current = current[part];\n    }\n\n    current[lastPart] = value;\n  }\n\n  /**\n   * Find comment by ID\n   */\n  private findComment(comments: TemplateComment[], id: string): TemplateComment | null {\n    for (const comment of comments) {\n      if (comment.id === id) return comment;\n      const found = this.findComment(comment.replies, id);\n      if (found) return found;\n    }\n    return null;\n  }\n\n  /**\n   * Get sync queue\n   */\n  getSyncQueue(): SyncMessage[] {\n    const queue = [...this.syncQueue];\n    this.syncQueue = [];\n    return queue;\n  }\n\n  /**\n   * Get statistics\n   */\n  getStatistics(): Record<string, any> {\n    let totalTemplates = 0;\n    let totalActiveUsers = 0;\n    let totalChanges = 0;\n    let totalComments = 0;\n    let totalConflicts = 0;\n\n    for (const template of this.templates.values()) {\n      totalTemplates++;\n      totalActiveUsers += template.activeUsers.length;\n      totalChanges += template.changeHistory.length;\n      totalComments += template.comments.length;\n      totalConflicts += template.conflicts.length;\n    }\n\n    return {\n      totalTemplates,\n      totalActiveUsers,\n      totalChanges,\n      totalComments,\n      totalConflicts,\n      averageChangesPerTemplate: totalTemplates > 0 ? totalChanges / totalTemplates : 0,\n    };\n  }\n}\n\nexport default CollaborativeTemplateManager;\n
