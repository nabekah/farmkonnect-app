import { describe, it, expect, beforeEach, vi } from 'vitest';\nimport NotificationsSystem from './notifications-system';\nimport RateLimitingSystem from './rate-limiting';\n\ndescribe('NotificationsSystem', () => {\n  let notifSystem: NotificationsSystem;\n\n  beforeEach(() => {\n    notifSystem = new NotificationsSystem();\n  });\n\n  describe('Sending Notifications', () => {\n    it('should send notification', async () => {\n      const notif = await notifSystem.sendNotification(\n        'user-1',\n        'export_complete',\n        'Export Complete',\n        'Your export has been completed successfully'\n      );\n\n      expect(notif).toBeDefined();\n      expect(notif.userId).toBe('user-1');\n      expect(notif.status).toBe('unread');\n    });\n\n    it('should send notification with priority', async () => {\n      const notif = await notifSystem.sendNotification(\n        'user-1',\n        'critical_error',\n        'Critical Error',\n        'A critical error occurred',\n        { priority: 'critical' }\n      );\n\n      expect(notif.priority).toBe('critical');\n    });\n\n    it('should send notification with action', async () => {\n      const notif = await notifSystem.sendNotification(\n        'user-1',\n        'export_complete',\n        'Export Ready',\n        'Your export is ready to download',\n        {\n          actionUrl: '/exports/123',\n          actionLabel: 'Download',\n        }\n      );\n\n      expect(notif.actionUrl).toBe('/exports/123');\n      expect(notif.actionLabel).toBe('Download');\n    });\n  });\n\n  describe('Notification Management', () => {\n    beforeEach(async () => {\n      await notifSystem.sendNotification('user-1', 'export_complete', 'Export 1', 'Message 1');\n      await notifSystem.sendNotification('user-1', 'export_complete', 'Export 2', 'Message 2');\n      await notifSystem.sendNotification('user-2', 'sync_completed', 'Sync Done', 'Message 3');\n    });\n\n    it('should get user notifications', () => {\n      const notifs = notifSystem.getNotifications('user-1');\n      expect(notifs.length).toBeGreaterThanOrEqual(2);\n      expect(notifs.every((n) => n.userId === 'user-1')).toBe(true);\n    });\n\n    it('should mark notification as read', () => {\n      const notifs = notifSystem.getNotifications('user-1');\n      const notif = notifs[0];\n\n      const marked = notifSystem.markAsRead(notif.id);\n      expect(marked).toBe(true);\n\n      const updated = notifSystem.getNotifications('user-1', 'read');\n      expect(updated.some((n) => n.id === notif.id)).toBe(true);\n    });\n\n    it('should mark all as read', () => {\n      const count = notifSystem.markAllAsRead('user-1');\n      expect(count).toBeGreaterThanOrEqual(2);\n    });\n\n    it('should archive notification', () => {\n      const notifs = notifSystem.getNotifications('user-1');\n      const archived = notifSystem.archiveNotification(notifs[0].id);\n\n      expect(archived).toBe(true);\n    });\n\n    it('should delete notification', () => {\n      const notifs = notifSystem.getNotifications('user-1');\n      const deleted = notifSystem.deleteNotification(notifs[0].id);\n\n      expect(deleted).toBe(true);\n    });\n  });\n\n  describe('Preferences', () => {\n    it('should set preference', () => {\n      notifSystem.setPreference('user-1', 'export_complete', {\n        enabled: true,\n        channels: ['in_app', 'email'],\n      });\n\n      const prefs = notifSystem.getPreferences('user-1');\n      const pref = prefs.find((p) => p.type === 'export_complete');\n\n      expect(pref?.enabled).toBe(true);\n      expect(pref?.channels).toContain('email');\n    });\n\n    it('should get default preferences', () => {\n      const prefs = notifSystem.getPreferences('user-new');\n      expect(prefs.length).toBeGreaterThan(0);\n    });\n  });\n\n  describe('Channels', () => {\n    it('should add channel', () => {\n      const channel = notifSystem.addChannel('user-1', {\n        type: 'email',\n        address: 'user@example.com',\n        isActive: true,\n      });\n\n      expect(channel).toBeDefined();\n      expect(channel.address).toBe('user@example.com');\n    });\n\n    it('should get channels', () => {\n      notifSystem.addChannel('user-1', {\n        type: 'email',\n        address: 'user@example.com',\n        isActive: true,\n      });\n\n      const channels = notifSystem.getChannels('user-1');\n      expect(channels.length).toBeGreaterThan(0);\n    });\n\n    it('should remove channel', () => {\n      const channel = notifSystem.addChannel('user-1', {\n        type: 'email',\n        address: 'user@example.com',\n        isActive: true,\n      });\n\n      const removed = notifSystem.removeChannel('user-1', channel.id);\n      expect(removed).toBe(true);\n    });\n  });\n\n  describe('Statistics', () => {\n    it('should get statistics', async () => {\n      await notifSystem.sendNotification('user-1', 'export_complete', 'Export', 'Message');\n      await notifSystem.sendNotification('user-1', 'critical_error', 'Error', 'Message');\n\n      const stats = notifSystem.getStatistics();\n\n      expect(stats).toBeDefined();\n      expect(stats.totalNotifications).toBeGreaterThanOrEqual(2);\n    });\n\n    it('should get unread count', async () => {\n      await notifSystem.sendNotification('user-1', 'export_complete', 'Export', 'Message');\n      await notifSystem.sendNotification('user-1', 'export_complete', 'Export', 'Message');\n\n      const count = notifSystem.getUnreadCount('user-1');\n      expect(count).toBeGreaterThanOrEqual(2);\n    });\n  });\n\n  describe('Bulk Operations', () => {\n    it('should send bulk notifications', async () => {\n      const notifs = await notifSystem.bulkSend(\n        ['user-1', 'user-2', 'user-3'],\n        'export_complete',\n        'Export Complete',\n        'Your export is ready'\n      );\n\n      expect(notifs.length).toBe(3);\n    });\n  });\n});\n\ndescribe('RateLimitingSystem', () => {\n  let rateLimiter: RateLimitingSystem;\n\n  beforeEach(() => {\n    rateLimiter = new RateLimitingSystem({\n      strategy: 'token_bucket',\n      windowSize: 60000,\n      maxRequests: 100,\n      perUser: true,\n    });\n  });\n\n  describe('Rate Limiting', () => {\n    it('should allow request under limit', () => {\n      const result = rateLimiter.checkRateLimit('user-1');\n      expect(result.allowed).toBe(true);\n    });\n\n    it('should block request over limit', () => {\n      // Fill the bucket\n      for (let i = 0; i < 100; i++) {\n        rateLimiter.checkRateLimit('user-1');\n      }\n\n      // Next request should be blocked\n      const result = rateLimiter.checkRateLimit('user-1');\n      expect(result.allowed).toBe(false);\n    });\n\n    it('should track remaining requests', () => {\n      const result = rateLimiter.checkRateLimit('user-1');\n      expect(result.remaining).toBeDefined();\n      expect(result.remaining).toBeLessThan(100);\n    });\n\n    it('should provide retry after', () => {\n      for (let i = 0; i < 100; i++) {\n        rateLimiter.checkRateLimit('user-1');\n      }\n\n      const result = rateLimiter.checkRateLimit('user-1');\n      expect(result.retryAfter).toBeDefined();\n      expect(result.retryAfter).toBeGreaterThan(0);\n    });\n  });\n\n  describe('Throttling', () => {\n    it('should execute request immediately if under capacity', async () => {\n      const result = await rateLimiter.throttleRequest(async () => {\n        return 'success';\n      });\n\n      expect(result).toBe('success');\n    });\n\n    it('should queue request if over capacity', async () => {\n      const results: string[] = [];\n\n      // Create many concurrent requests\n      const promises = [];\n      for (let i = 0; i < 5; i++) {\n        promises.push(\n          rateLimiter.throttleRequest(async () => {\n            results.push(`request-${i}`);\n            return `result-${i}`;\n          }, 0)\n        );\n      }\n\n      await Promise.all(promises);\n      expect(results.length).toBe(5);\n    });\n  });\n\n  describe('Statistics', () => {\n    it('should get statistics', () => {\n      rateLimiter.checkRateLimit('user-1');\n      rateLimiter.checkRateLimit('user-1');\n\n      const stats = rateLimiter.getStatistics();\n\n      expect(stats).toBeDefined();\n      expect(stats.totalRequests).toBeGreaterThanOrEqual(2);\n    });\n\n    it('should get queue status', async () => {\n      const status = rateLimiter.getQueueStatus();\n\n      expect(status).toBeDefined();\n      expect(status.queueLength).toBeGreaterThanOrEqual(0);\n      expect(status.activeRequests).toBeGreaterThanOrEqual(0);\n    });\n  });\n\n  describe('Configuration', () => {\n    it('should update config', () => {\n      rateLimiter.updateConfig({ maxRequests: 200 });\n      const status = rateLimiter.getQueueStatus();\n\n      expect(status.maxConcurrent).toBeGreaterThanOrEqual(0);\n    });\n\n    it('should clear buckets', () => {\n      rateLimiter.checkRateLimit('user-1');\n      rateLimiter.checkRateLimit('user-2');\n      rateLimiter.clearBuckets();\n\n      const info = rateLimiter.getBucketInfo('user-1');\n      expect(info).toBeUndefined();\n    });\n  });\n\n  describe('Different Strategies', () => {\n    it('should support fixed window strategy', () => {\n      const limiter = new RateLimitingSystem({\n        strategy: 'fixed_window',\n        windowSize: 60000,\n        maxRequests: 50,\n      });\n\n      for (let i = 0; i < 50; i++) {\n        const result = limiter.checkRateLimit('user-1');\n        expect(result.allowed).toBe(true);\n      }\n\n      const result = limiter.checkRateLimit('user-1');\n      expect(result.allowed).toBe(false);\n    });\n\n    it('should support sliding window strategy', () => {\n      const limiter = new RateLimitingSystem({\n        strategy: 'sliding_window',\n        windowSize: 60000,\n        maxRequests: 50,\n      });\n\n      const result = limiter.checkRateLimit('user-1');\n      expect(result.allowed).toBe(true);\n    });\n  });\n});\n\ndescribe('Integration Tests', () => {\n  let notifSystem: NotificationsSystem;\n  let rateLimiter: RateLimitingSystem;\n\n  beforeEach(() => {\n    notifSystem = new NotificationsSystem();\n    rateLimiter = new RateLimitingSystem();\n  });\n\n  it('should integrate notifications with rate limiting', async () => {\n    // Check rate limit\n    const allowed = rateLimiter.checkRateLimit('user-1');\n\n    if (allowed.allowed) {\n      // Send notification if allowed\n      const notif = await notifSystem.sendNotification(\n        'user-1',\n        'export_complete',\n        'Export',\n        'Message'\n      );\n\n      expect(notif).toBeDefined();\n    }\n  });\n\n  it('should handle concurrent operations', async () => {\n    const promises = [];\n\n    // Send multiple notifications\n    for (let i = 0; i < 5; i++) {\n      promises.push(\n        notifSystem.sendNotification(\n          `user-${i}`,\n          'export_complete',\n          `Export ${i}`,\n          `Message ${i}`\n        )\n      );\n    }\n\n    // Check rate limits\n    for (let i = 0; i < 5; i++) {\n      rateLimiter.checkRateLimit(`user-${i}`);\n    }\n\n    await Promise.all(promises);\n\n    const notifStats = notifSystem.getStatistics();\n    const rateLimitStats = rateLimiter.getStatistics();\n\n    expect(notifStats.totalNotifications).toBeGreaterThanOrEqual(5);\n    expect(rateLimitStats.totalRequests).toBeGreaterThanOrEqual(5);\n  });\n\n  it('should enforce rate limits on bulk notifications', async () => {\n    // Try to send bulk notifications\n    const userIds = Array.from({ length: 100 }, (_, i) => `user-${i}`);\n\n    // Check rate limit for each user\n    let blockedCount = 0;\n    for (const userId of userIds) {\n      const result = rateLimiter.checkRateLimit(userId);\n      if (!result.allowed) {\n        blockedCount++;\n      }\n    }\n\n    // Should allow most requests\n    expect(blockedCount).toBeLessThan(userIds.length);\n  });\n});\n
