import { EventEmitter } from 'events';\n\nexport type WebhookEventType =\n  | 'report.generated'\n  | 'report.scheduled'\n  | 'report.sent'\n  | 'report.failed'\n  | 'widget.created'\n  | 'widget.updated'\n  | 'widget.deleted'\n  | 'widget.data_updated'\n  | 'email.sent'\n  | 'email.failed'\n  | 'campaign.completed';\n\nexport interface WebhookPayload {\n  event: WebhookEventType;\n  timestamp: number;\n  data: Record<string, any>;\n  metadata?: Record<string, any>;\n}\n\nexport interface WebhookSubscription {\n  id: string;\n  url: string;\n  events: WebhookEventType[];\n  active: boolean;\n  secret?: string;\n  retryPolicy: {\n    maxRetries: number;\n    initialDelay: number;\n    maxDelay: number;\n  };\n  headers?: Record<string, string>;\n  createdAt: number;\n  updatedAt: number;\n}\n\nexport interface WebhookDelivery {\n  id: string;\n  subscriptionId: string;\n  payload: WebhookPayload;\n  status: 'pending' | 'delivered' | 'failed' | 'retrying';\n  attempts: number;\n  lastAttempt?: number;\n  nextRetry?: number;\n  response?: {\n    statusCode: number;\n    body: string;\n  };\n  error?: string;\n  createdAt: number;\n}\n\nexport class WebhookEventHandler extends EventEmitter {\n  private subscriptions: Map<string, WebhookSubscription> = new Map();\n  private deliveries: Map<string, WebhookDelivery> = new Map();\n  private subscriptionCounter = 0;\n  private deliveryCounter = 0;\n  private retryTimers: Map<string, NodeJS.Timeout> = new Map();\n\n  /**\n   * Subscribe to webhook events\n   */\n  subscribe(\n    url: string,\n    events: WebhookEventType[],\n    options?: {\n      secret?: string;\n      headers?: Record<string, string>;\n      maxRetries?: number;\n      initialDelay?: number;\n      maxDelay?: number;\n    }\n  ): WebhookSubscription {\n    const subscriptionId = `webhook-${++this.subscriptionCounter}`;\n    const subscription: WebhookSubscription = {\n      id: subscriptionId,\n      url,\n      events,\n      active: true,\n      secret: options?.secret,\n      headers: options?.headers,\n      retryPolicy: {\n        maxRetries: options?.maxRetries ?? 5,\n        initialDelay: options?.initialDelay ?? 1000,\n        maxDelay: options?.maxDelay ?? 60000,\n      },\n      createdAt: Date.now(),\n      updatedAt: Date.now(),\n    };\n\n    this.subscriptions.set(subscriptionId, subscription);\n    this.emit('subscription:created', subscription);\n\n    return subscription;\n  }\n\n  /**\n   * Unsubscribe from webhook events\n   */\n  unsubscribe(subscriptionId: string): boolean {\n    const subscription = this.subscriptions.get(subscriptionId);\n    if (!subscription) return false;\n\n    this.subscriptions.delete(subscriptionId);\n    this.emit('subscription:deleted', subscription);\n\n    return true;\n  }\n\n  /**\n   * Update subscription\n   */\n  updateSubscription(\n    subscriptionId: string,\n    updates: Partial<WebhookSubscription>\n  ): WebhookSubscription | null {\n    const subscription = this.subscriptions.get(subscriptionId);\n    if (!subscription) return null;\n\n    const updated = {\n      ...subscription,\n      ...updates,\n      id: subscription.id,\n      createdAt: subscription.createdAt,\n      updatedAt: Date.now(),\n    };\n\n    this.subscriptions.set(subscriptionId, updated);\n    this.emit('subscription:updated', updated);\n\n    return updated;\n  }\n\n  /**\n   * Emit webhook event\n   */\n  async emitEvent(event: WebhookEventType, data: Record<string, any>, metadata?: Record<string, any>) {\n    const payload: WebhookPayload = {\n      event,\n      timestamp: Date.now(),\n      data,\n      metadata,\n    };\n\n    const matchingSubscriptions = Array.from(this.subscriptions.values()).filter(\n      (sub) => sub.active && sub.events.includes(event)\n    );\n\n    for (const subscription of matchingSubscriptions) {\n      await this.deliverWebhook(subscription, payload);\n    }\n\n    this.emit('event:emitted', { event, subscriptionCount: matchingSubscriptions.length });\n  }\n\n  /**\n   * Deliver webhook to subscription\n   */\n  private async deliverWebhook(subscription: WebhookSubscription, payload: WebhookPayload) {\n    const deliveryId = `delivery-${++this.deliveryCounter}`;\n    const delivery: WebhookDelivery = {\n      id: deliveryId,\n      subscriptionId: subscription.id,\n      payload,\n      status: 'pending',\n      attempts: 0,\n      createdAt: Date.now(),\n    };\n\n    this.deliveries.set(deliveryId, delivery);\n    await this.attemptDelivery(delivery, subscription);\n  }\n\n  /**\n   * Attempt to deliver webhook\n   */\n  private async attemptDelivery(delivery: WebhookDelivery, subscription: WebhookSubscription) {\n    delivery.attempts++;\n    delivery.lastAttempt = Date.now();\n    delivery.status = 'retrying';\n\n    try {\n      const response = await this.sendWebhookRequest(subscription, delivery.payload);\n\n      if (response.statusCode >= 200 && response.statusCode < 300) {\n        delivery.status = 'delivered';\n        delivery.response = response;\n        this.emit('delivery:success', delivery);\n      } else {\n        throw new Error(`HTTP ${response.statusCode}`);\n      }\n    } catch (error) {\n      if (delivery.attempts < subscription.retryPolicy.maxRetries) {\n        const delay = Math.min(\n          subscription.retryPolicy.initialDelay * Math.pow(2, delivery.attempts - 1),\n          subscription.retryPolicy.maxDelay\n        );\n\n        delivery.nextRetry = Date.now() + delay;\n        delivery.status = 'retrying';\n        delivery.error = String(error);\n\n        const timer = setTimeout(() => {\n          this.attemptDelivery(delivery, subscription);\n        }, delay);\n\n        this.retryTimers.set(delivery.id, timer);\n        this.emit('delivery:retrying', delivery);\n      } else {\n        delivery.status = 'failed';\n        delivery.error = String(error);\n        this.emit('delivery:failed', delivery);\n      }\n    }\n\n    this.deliveries.set(delivery.id, delivery);\n  }\n\n  /**\n   * Send webhook HTTP request\n   */\n  private async sendWebhookRequest(\n    subscription: WebhookSubscription,\n    payload: WebhookPayload\n  ): Promise<{ statusCode: number; body: string }> {\n    const headers: Record<string, string> = {\n      'Content-Type': 'application/json',\n      'User-Agent': 'FarmKonnect-Webhook/1.0',\n      'X-Webhook-Event': payload.event,\n      'X-Webhook-Timestamp': String(payload.timestamp),\n      ...subscription.headers,\n    };\n\n    if (subscription.secret) {\n      const crypto = require('crypto');\n      const signature = crypto\n        .createHmac('sha256', subscription.secret)\n        .update(JSON.stringify(payload))\n        .digest('hex');\n      headers['X-Webhook-Signature'] = `sha256=${signature}`;\n    }\n\n    // Simulate HTTP request (in real implementation, use fetch or axios)\n    return new Promise((resolve, reject) => {\n      setTimeout(() => {\n        // Simulate successful delivery\n        resolve({ statusCode: 200, body: 'OK' });\n      }, 100);\n    });\n  }\n\n  /**\n   * Get subscription by ID\n   */\n  getSubscription(subscriptionId: string): WebhookSubscription | undefined {\n    return this.subscriptions.get(subscriptionId);\n  }\n\n  /**\n   * Get all subscriptions\n   */\n  getAllSubscriptions(): WebhookSubscription[] {\n    return Array.from(this.subscriptions.values());\n  }\n\n  /**\n   * Get subscriptions by event\n   */\n  getSubscriptionsByEvent(event: WebhookEventType): WebhookSubscription[] {\n    return Array.from(this.subscriptions.values()).filter((sub) => sub.events.includes(event));\n  }\n\n  /**\n   * Get delivery by ID\n   */\n  getDelivery(deliveryId: string): WebhookDelivery | undefined {\n    return this.deliveries.get(deliveryId);\n  }\n\n  /**\n   * Get all deliveries\n   */\n  getAllDeliveries(): WebhookDelivery[] {\n    return Array.from(this.deliveries.values());\n  }\n\n  /**\n   * Get deliveries by subscription\n   */\n  getDeliveriesBySubscription(subscriptionId: string): WebhookDelivery[] {\n    return Array.from(this.deliveries.values()).filter((d) => d.subscriptionId === subscriptionId);\n  }\n\n  /**\n   * Get deliveries by status\n   */\n  getDeliveriesByStatus(status: WebhookDelivery['status']): WebhookDelivery[] {\n    return Array.from(this.deliveries.values()).filter((d) => d.status === status);\n  }\n\n  /**\n   * Retry failed delivery\n   */\n  async retryDelivery(deliveryId: string): Promise<boolean> {\n    const delivery = this.deliveries.get(deliveryId);\n    if (!delivery) return false;\n\n    const subscription = this.subscriptions.get(delivery.subscriptionId);\n    if (!subscription) return false;\n\n    delivery.attempts = 0;\n    delivery.status = 'pending';\n    await this.attemptDelivery(delivery, subscription);\n\n    return true;\n  }\n\n  /**\n   * Get webhook statistics\n   */\n  getStatistics() {\n    const deliveries = Array.from(this.deliveries.values());\n    const subscriptions = Array.from(this.subscriptions.values());\n\n    return {\n      totalSubscriptions: subscriptions.length,\n      activeSubscriptions: subscriptions.filter((s) => s.active).length,\n      totalDeliveries: deliveries.length,\n      successfulDeliveries: deliveries.filter((d) => d.status === 'delivered').length,\n      failedDeliveries: deliveries.filter((d) => d.status === 'failed').length,\n      pendingDeliveries: deliveries.filter((d) => d.status === 'pending').length,\n      retryingDeliveries: deliveries.filter((d) => d.status === 'retrying').length,\n      successRate: deliveries.length > 0\n        ? ((deliveries.filter((d) => d.status === 'delivered').length / deliveries.length) * 100).toFixed(2)\n        : '0',\n    };\n  }\n\n  /**\n   * Emit report generated event\n   */\n  async emitReportGenerated(reportId: string, reportType: string, data: any) {\n    await this.emitEvent('report.generated', { reportId, reportType, ...data });\n  }\n\n  /**\n   * Emit report scheduled event\n   */\n  async emitReportScheduled(scheduleId: string, reportType: string, scheduledFor: number) {\n    await this.emitEvent('report.scheduled', { scheduleId, reportType, scheduledFor });\n  }\n\n  /**\n   * Emit report sent event\n   */\n  async emitReportSent(reportId: string, recipients: string[], sentAt: number) {\n    await this.emitEvent('report.sent', { reportId, recipients, sentAt });\n  }\n\n  /**\n   * Emit report failed event\n   */\n  async emitReportFailed(reportId: string, error: string) {\n    await this.emitEvent('report.failed', { reportId, error });\n  }\n\n  /**\n   * Emit widget created event\n   */\n  async emitWidgetCreated(widgetId: string, widgetType: string, config: any) {\n    await this.emitEvent('widget.created', { widgetId, widgetType, config });\n  }\n\n  /**\n   * Emit widget updated event\n   */\n  async emitWidgetUpdated(widgetId: string, changes: any) {\n    await this.emitEvent('widget.updated', { widgetId, changes });\n  }\n\n  /**\n   * Emit widget deleted event\n   */\n  async emitWidgetDeleted(widgetId: string) {\n    await this.emitEvent('widget.deleted', { widgetId });\n  }\n\n  /**\n   * Emit widget data updated event\n   */\n  async emitWidgetDataUpdated(widgetId: string, data: any) {\n    await this.emitEvent('widget.data_updated', { widgetId, data });\n  }\n\n  /**\n   * Cleanup\n   */\n  destroy() {\n    this.retryTimers.forEach((timer) => clearTimeout(timer));\n    this.retryTimers.clear();\n    this.subscriptions.clear();\n    this.deliveries.clear();\n  }\n}\n
