import { EventEmitter } from 'events';\n\nexport type NotificationChannel = 'email' | 'sms' | 'push' | 'in-app';\nexport type NotificationPriority = 'low' | 'normal' | 'high' | 'urgent';\nexport type NotificationStatus = 'pending' | 'sent' | 'delivered' | 'failed' | 'bounced';\n\nexport interface NotificationRecipient {\n  userId: string;\n  email?: string;\n  phoneNumber?: string;\n  pushToken?: string;\n  preferences: {\n    channels: NotificationChannel[];\n    doNotDisturb: boolean;\n    doNotDisturbStart?: number; // hour\n    doNotDisturbEnd?: number; // hour\n  };\n}\n\nexport interface NotificationPayload {\n  id: string;\n  userId: string;\n  title: string;\n  body: string;\n  channels: NotificationChannel[];\n  priority: NotificationPriority;\n  data?: Record<string, any>;\n  actionUrl?: string;\n  imageUrl?: string;\n  createdAt: number;\n  sentAt?: number;\n  status: NotificationStatus;\n  retries: number;\n  maxRetries: number;\n}\n\nexport interface NotificationTemplate {\n  id: string;\n  name: string;\n  title: string;\n  body: string;\n  variables: string[];\n  channels: NotificationChannel[];\n  priority: NotificationPriority;\n}\n\nexport interface NotificationLog {\n  notificationId: string;\n  userId: string;\n  channel: NotificationChannel;\n  status: NotificationStatus;\n  timestamp: number;\n  error?: string;\n  deliveredAt?: number;\n}\n\n/**\n * Push Notifications Manager\n */\nexport class PushNotificationsManager extends EventEmitter {\n  private notifications: Map<string, NotificationPayload> = new Map();\n  private recipients: Map<string, NotificationRecipient> = new Map();\n  private templates: Map<string, NotificationTemplate> = new Map();\n  private logs: NotificationLog[] = [];\n  private queue: NotificationPayload[] = [];\n  private processingInterval: NodeJS.Timer | null = null;\n\n  constructor() {\n    super();\n    this.initializeTemplates();\n    this.startQueueProcessor();\n  }\n\n  /**\n   * Initialize default templates\n   */\n  private initializeTemplates(): void {\n    const templates: NotificationTemplate[] = [\n      {\n        id: 'alert-high-temp',\n        name: 'High Temperature Alert',\n        title: 'High Temperature Detected',\n        body: 'Temperature in {{farmName}} has exceeded {{threshold}}Â°C',\n        variables: ['farmName', 'threshold', 'currentTemp'],\n        channels: ['push', 'email', 'sms'],\n        priority: 'high',\n      },\n      {\n        id: 'alert-low-moisture',\n        name: 'Low Soil Moisture Alert',\n        title: 'Low Soil Moisture',\n        body: 'Soil moisture in {{farmName}} is at {{moisture}}%',\n        variables: ['farmName', 'moisture'],\n        channels: ['push', 'email'],\n        priority: 'normal',\n      },\n      {\n        id: 'task-assigned',\n        name: 'Task Assignment',\n        title: 'New Task Assigned',\n        body: '{{assignedBy}} assigned you: {{taskTitle}}',\n        variables: ['assignedBy', 'taskTitle'],\n        channels: ['push', 'in-app'],\n        priority: 'normal',\n      },\n      {\n        id: 'report-ready',\n        name: 'Report Ready',\n        title: 'Your Report is Ready',\n        body: '{{reportType}} report for {{farmName}} is ready to download',\n        variables: ['reportType', 'farmName'],\n        channels: ['email', 'in-app'],\n        priority: 'normal',\n      },\n    ];\n\n    for (const template of templates) {\n      this.templates.set(template.id, template);\n    }\n  }\n\n  /**\n   * Register recipient\n   */\n  registerRecipient(userId: string, recipient: Partial<NotificationRecipient>): NotificationRecipient {\n    const newRecipient: NotificationRecipient = {\n      userId,\n      preferences: {\n        channels: ['push', 'email'],\n        doNotDisturb: false,\n      },\n      ...recipient,\n    };\n\n    this.recipients.set(userId, newRecipient);\n    this.emit('recipient:registered', { userId });\n    return newRecipient;\n  }\n\n  /**\n   * Send notification\n   */\n  async sendNotification(\n    userId: string,\n    title: string,\n    body: string,\n    channels: NotificationChannel[] = ['push', 'email'],\n    priority: NotificationPriority = 'normal',\n    data?: Record<string, any>\n  ): Promise<NotificationPayload> {\n    const notificationId = `notif-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n\n    const notification: NotificationPayload = {\n      id: notificationId,\n      userId,\n      title,\n      body,\n      channels,\n      priority,\n      data,\n      createdAt: Date.now(),\n      status: 'pending',\n      retries: 0,\n      maxRetries: 3,\n    };\n\n    this.notifications.set(notificationId, notification);\n    this.queue.push(notification);\n\n    this.emit('notification:queued', { notificationId, userId });\n    return notification;\n  }\n\n  /**\n   * Send from template\n   */\n  async sendFromTemplate(\n    userId: string,\n    templateId: string,\n    variables: Record<string, any>\n  ): Promise<NotificationPayload> {\n    const template = this.templates.get(templateId);\n    if (!template) throw new Error('Template not found');\n\n    let title = template.title;\n    let body = template.body;\n\n    for (const [key, value] of Object.entries(variables)) {\n      title = title.replace(`{{${key}}}`, String(value));\n      body = body.replace(`{{${key}}}`, String(value));\n    }\n\n    return this.sendNotification(userId, title, body, template.channels, template.priority, variables);\n  }\n\n  /**\n   * Start queue processor\n   */\n  private startQueueProcessor(): void {\n    this.processingInterval = setInterval(() => {\n      this.processQueue();\n    }, 5000); // Process every 5 seconds\n  }\n\n  /**\n   * Process notification queue\n   */\n  private async processQueue(): Promise<void> {\n    while (this.queue.length > 0) {\n      const notification = this.queue.shift();\n      if (!notification) break;\n\n      const recipient = this.recipients.get(notification.userId);\n      if (!recipient) {\n        notification.status = 'failed';\n        continue;\n      }\n\n      // Check do not disturb\n      if (recipient.preferences.doNotDisturb) {\n        const now = new Date();\n        const hour = now.getHours();\n        const start = recipient.preferences.doNotDisturbStart || 22;\n        const end = recipient.preferences.doNotDisturbEnd || 8;\n\n        if (start < end) {\n          if (hour >= start || hour < end) {\n            this.queue.unshift(notification); // Re-queue\n            continue;\n          }\n        } else {\n          if (hour >= start || hour < end) {\n            this.queue.unshift(notification);\n            continue;\n          }\n        }\n      }\n\n      // Send through enabled channels\n      for (const channel of notification.channels) {\n        if (!recipient.preferences.channels.includes(channel)) continue;\n\n        const success = await this.sendThroughChannel(notification, recipient, channel);\n        const log: NotificationLog = {\n          notificationId: notification.id,\n          userId: notification.userId,\n          channel,\n          status: success ? 'delivered' : 'failed',\n          timestamp: Date.now(),\n          deliveredAt: success ? Date.now() : undefined,\n        };\n\n        this.logs.push(log);\n        this.emit('notification:sent', log);\n      }\n\n      notification.status = 'sent';\n      notification.sentAt = Date.now();\n    }\n  }\n\n  /**\n   * Send through channel\n   */\n  private async sendThroughChannel(\n    notification: NotificationPayload,\n    recipient: NotificationRecipient,\n    channel: NotificationChannel\n  ): Promise<boolean> {\n    try {\n      switch (channel) {\n        case 'email':\n          return await this.sendEmail(recipient.email!, notification);\n        case 'sms':\n          return await this.sendSMS(recipient.phoneNumber!, notification);\n        case 'push':\n          return await this.sendPush(recipient.pushToken!, notification);\n        case 'in-app':\n          return await this.sendInApp(notification);\n        default:\n          return false;\n      }\n    } catch (error) {\n      console.error(`Failed to send ${channel} notification:`, error);\n      return false;\n    }\n  }\n\n  /**\n   * Send email\n   */\n  private async sendEmail(email: string, notification: NotificationPayload): Promise<boolean> {\n    // Simulated email sending\n    console.log(`Sending email to ${email}: ${notification.title}`);\n    return Math.random() > 0.1; // 90% success rate\n  }\n\n  /**\n   * Send SMS\n   */\n  private async sendSMS(phoneNumber: string, notification: NotificationPayload): Promise<boolean> {\n    // Simulated SMS sending\n    console.log(`Sending SMS to ${phoneNumber}: ${notification.title}`);\n    return Math.random() > 0.15; // 85% success rate\n  }\n\n  /**\n   * Send push notification\n   */\n  private async sendPush(pushToken: string, notification: NotificationPayload): Promise<boolean> {\n    // Simulated push notification\n    console.log(`Sending push to ${pushToken}: ${notification.title}`);\n    return Math.random() > 0.05; // 95% success rate\n  }\n\n  /**\n   * Send in-app notification\n   */\n  private async sendInApp(notification: NotificationPayload): Promise<boolean> {\n    // In-app notifications always succeed\n    console.log(`Storing in-app notification: ${notification.title}`);\n    return true;\n  }\n\n  /**\n   * Get notification\n   */\n  getNotification(notificationId: string): NotificationPayload | null {\n    return this.notifications.get(notificationId) || null;\n  }\n\n  /**\n   * Get notifications by user\n   */\n  getNotificationsByUser(userId: string): NotificationPayload[] {\n    return Array.from(this.notifications.values()).filter((n) => n.userId === userId);\n  }\n\n  /**\n   * Get notification logs\n   */\n  getNotificationLogs(userId?: string, limit: number = 50): NotificationLog[] {\n    let logs = this.logs;\n    if (userId) {\n      logs = logs.filter((l) => l.userId === userId);\n    }\n    return logs.slice(-limit);\n  }\n\n  /**\n   * Get template\n   */\n  getTemplate(templateId: string): NotificationTemplate | null {\n    return this.templates.get(templateId) || null;\n  }\n\n  /**\n   * Get all templates\n   */\n  getTemplates(): NotificationTemplate[] {\n    return Array.from(this.templates.values());\n  }\n\n  /**\n   * Get notification stats\n   */\n  getNotificationStats(): {\n    totalSent: number;\n    totalPending: number;\n    totalFailed: number;\n    byChannel: Record<NotificationChannel, number>;\n    successRate: number;\n  } {\n    const sent = Array.from(this.notifications.values()).filter((n) => n.status === 'sent').length;\n    const pending = this.queue.length;\n    const failed = Array.from(this.notifications.values()).filter((n) => n.status === 'failed').length;\n\n    const byChannel: Record<NotificationChannel, number> = {\n      email: 0,\n      sms: 0,\n      push: 0,\n      'in-app': 0,\n    };\n\n    for (const log of this.logs) {\n      if (log.status === 'delivered') {\n        byChannel[log.channel]++;\n      }\n    }\n\n    const total = sent + failed;\n    const successRate = total > 0 ? (sent / total) * 100 : 0;\n\n    return {\n      totalSent: sent,\n      totalPending: pending,\n      totalFailed: failed,\n      byChannel,\n      successRate: Math.round(successRate),\n    };\n  }\n\n  /**\n   * Cleanup\n   */\n  destroy(): void {\n    if (this.processingInterval) {\n      clearInterval(this.processingInterval);\n    }\n  }\n}\n
