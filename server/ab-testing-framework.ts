import { EventEmitter } from 'events';\n\nexport type TestStatus = 'draft' | 'running' | 'paused' | 'completed' | 'cancelled';\nexport type VariantType = 'control' | 'treatment';\nexport type StatisticalTest = 'chi_square' | 'ttest' | 'proportion_test';\n\nexport interface TestVariant {\n  id: string;\n  name: string;\n  type: VariantType;\n  weight: number; // 0-100 percentage\n  description?: string;\n  config: Record<string, any>; // Template, timing, content variations\n}\n\nexport interface ABTest {\n  id: string;\n  name: string;\n  description: string;\n  hypothesis: string;\n  variants: TestVariant[];\n  status: TestStatus;\n  targetAudience?: string; // Segment ID\n  startDate: number;\n  endDate?: number;\n  sampleSize?: number;\n  confidenceLevel: number; // 0.90, 0.95, 0.99\n  minimalDetectableEffect: number; // Minimum effect size to detect\n  createdBy: string;\n  createdAt: number;\n  updatedAt: number;\n}\n\nexport interface TestMetrics {\n  variantId: string;\n  impressions: number;\n  clicks: number;\n  conversions: number;\n  clickRate: number;\n  conversionRate: number;\n  revenue?: number;\n  customMetrics: Record<string, number>;\n}\n\nexport interface TestResult {\n  variantId: string;\n  metrics: TestMetrics;\n  statisticalSignificance: number; // p-value\n  isSignificant: boolean;\n  confidenceInterval: { lower: number; upper: number };\n  estimatedEffect: number;\n}\n\nexport interface UserTestAssignment {\n  id: string;\n  userId: string;\n  testId: string;\n  variantId: string;\n  assignedAt: number;\n  metadata?: Record<string, any>;\n}\n\nexport interface ABTestStatistics {\n  totalTests: number;\n  runningTests: number;\n  completedTests: number;\n  totalAssignments: number;\n  averageTestDuration: number;\n  significantResults: number;\n}\n\nclass ABTestingFramework extends EventEmitter {\n  private tests: Map<string, ABTest> = new Map();\n  private variants: Map<string, TestVariant> = new Map();\n  private assignments: Map<string, UserTestAssignment> = new Map();\n  private userAssignments: Map<string, Set<string>> = new Map(); // userId -> testIds\n  private metrics: Map<string, TestMetrics> = new Map();\n  private results: Map<string, TestResult[]> = new Map(); // testId -> results\n  private statistics: ABTestStatistics = {\n    totalTests: 0,\n    runningTests: 0,\n    completedTests: 0,\n    totalAssignments: 0,\n    averageTestDuration: 0,\n    significantResults: 0,\n  };\n  private testDurations: number[] = [];\n\n  constructor() {\n    super();\n  }\n\n  /**\n   * Create AB test\n   */\n  createTest(\n    name: string,\n    description: string,\n    hypothesis: string,\n    variants: Omit<TestVariant, 'id'>[],\n    createdBy: string,\n    options?: {\n      targetAudience?: string;\n      sampleSize?: number;\n      confidenceLevel?: number;\n      minimalDetectableEffect?: number;\n    }\n  ): ABTest {\n    // Validate variant weights sum to 100\n    const totalWeight = variants.reduce((sum, v) => sum + v.weight, 0);\n    if (totalWeight !== 100) {\n      throw new Error('Variant weights must sum to 100');\n    }\n\n    const test: ABTest = {\n      id: `test-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,\n      name,\n      description,\n      hypothesis,\n      variants: variants.map((v) => ({\n        ...v,\n        id: `var-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,\n      })),\n      status: 'draft',\n      targetAudience: options?.targetAudience,\n      startDate: Date.now(),\n      sampleSize: options?.sampleSize,\n      confidenceLevel: options?.confidenceLevel || 0.95,\n      minimalDetectableEffect: options?.minimalDetectableEffect || 0.05,\n      createdBy,\n      createdAt: Date.now(),\n      updatedAt: Date.now(),\n    };\n\n    this.tests.set(test.id, test);\n    this.statistics.totalTests++;\n\n    // Store variants\n    for (const variant of test.variants) {\n      this.variants.set(variant.id, variant);\n      this.metrics.set(variant.id, {\n        variantId: variant.id,\n        impressions: 0,\n        clicks: 0,\n        conversions: 0,\n        clickRate: 0,\n        conversionRate: 0,\n        customMetrics: {},\n      });\n    }\n\n    this.emit('test:created', test);\n    return test;\n  }\n\n  /**\n   * Start test\n   */\n  startTest(testId: string): boolean {\n    const test = this.tests.get(testId);\n    if (!test || test.status !== 'draft') return false;\n\n    test.status = 'running';\n    test.startDate = Date.now();\n    test.updatedAt = Date.now();\n    this.statistics.runningTests++;\n\n    this.emit('test:started', { testId });\n    return true;\n  }\n\n  /**\n   * Assign user to variant\n   */\n  assignUserToVariant(userId: string, testId: string): UserTestAssignment | null {\n    const test = this.tests.get(testId);\n    if (!test || test.status !== 'running') return null;\n\n    // Check if user already assigned\n    if (!this.userAssignments.has(userId)) {\n      this.userAssignments.set(userId, new Set());\n    }\n\n    const userTests = this.userAssignments.get(userId)!;\n    if (userTests.has(testId)) {\n      // Return existing assignment\n      for (const [assignmentId, assignment] of this.assignments.entries()) {\n        if (assignment.userId === userId && assignment.testId === testId) {\n          return assignment;\n        }\n      }\n    }\n\n    // Randomly assign based on variant weights\n    const variant = this.selectVariantByWeight(test.variants);\n\n    const assignment: UserTestAssignment = {\n      id: `assign-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,\n      userId,\n      testId,\n      variantId: variant.id,\n      assignedAt: Date.now(),\n    };\n\n    this.assignments.set(assignment.id, assignment);\n    userTests.add(testId);\n    this.statistics.totalAssignments++;\n\n    this.emit('user:assigned', assignment);\n    return assignment;\n  }\n\n  /**\n   * Select variant by weight\n   */\n  private selectVariantByWeight(variants: TestVariant[]): TestVariant {\n    const random = Math.random() * 100;\n    let cumulative = 0;\n\n    for (const variant of variants) {\n      cumulative += variant.weight;\n      if (random < cumulative) {\n        return variant;\n      }\n    }\n\n    return variants[variants.length - 1];\n  }\n\n  /**\n   * Record impression\n   */\n  recordImpression(variantId: string): void {\n    const metrics = this.metrics.get(variantId);\n    if (metrics) {\n      metrics.impressions++;\n      this.emit('metric:impression', { variantId });\n    }\n  }\n\n  /**\n   * Record click\n   */\n  recordClick(variantId: string): void {\n    const metrics = this.metrics.get(variantId);\n    if (metrics) {\n      metrics.clicks++;\n      metrics.clickRate = (metrics.clicks / Math.max(metrics.impressions, 1)) * 100;\n      this.emit('metric:click', { variantId });\n    }\n  }\n\n  /**\n   * Record conversion\n   */\n  recordConversion(variantId: string, value?: number): void {\n    const metrics = this.metrics.get(variantId);\n    if (metrics) {\n      metrics.conversions++;\n      metrics.conversionRate = (metrics.conversions / Math.max(metrics.impressions, 1)) * 100;\n\n      if (value) {\n        metrics.revenue = (metrics.revenue || 0) + value;\n      }\n\n      this.emit('metric:conversion', { variantId, value });\n    }\n  }\n\n  /**\n   * Record custom metric\n   */\n  recordCustomMetric(variantId: string, metricName: string, value: number): void {\n    const metrics = this.metrics.get(variantId);\n    if (metrics) {\n      metrics.customMetrics[metricName] = (metrics.customMetrics[metricName] || 0) + value;\n      this.emit('metric:custom', { variantId, metricName, value });\n    }\n  }\n\n  /**\n   * Get variant metrics\n   */\n  getVariantMetrics(variantId: string): TestMetrics | undefined {\n    return this.metrics.get(variantId);\n  }\n\n  /**\n   * Analyze test results\n   */\n  analyzeTestResults(testId: string, statisticalTest: StatisticalTest = 'chi_square'): TestResult[] {\n    const test = this.tests.get(testId);\n    if (!test) return [];\n\n    const results: TestResult[] = [];\n    const controlVariant = test.variants.find((v) => v.type === 'control');\n\n    if (!controlVariant) return [];\n\n    const controlMetrics = this.metrics.get(controlVariant.id);\n    if (!controlMetrics) return [];\n\n    for (const variant of test.variants) {\n      if (variant.type === 'control') continue;\n\n      const variantMetrics = this.metrics.get(variant.id);\n      if (!variantMetrics) continue;\n\n      const result = this.performStatisticalTest(\n        controlMetrics,\n        variantMetrics,\n        statisticalTest,\n        test.confidenceLevel\n      );\n\n      result.variantId = variant.id;\n      results.push(result);\n    }\n\n    this.results.set(testId, results);\n    this.emit('test:analyzed', { testId, results });\n\n    return results;\n  }\n\n  /**\n   * Perform statistical test\n   */\n  private performStatisticalTest(\n    controlMetrics: TestMetrics,\n    treatmentMetrics: TestMetrics,\n    testType: StatisticalTest,\n    confidenceLevel: number\n  ): TestResult {\n    let pValue = 0;\n    let estimatedEffect = 0;\n\n    switch (testType) {\n      case 'proportion_test':\n        // Two-proportion z-test\n        const p1 = controlMetrics.conversionRate / 100;\n        const p2 = treatmentMetrics.conversionRate / 100;\n        const n1 = controlMetrics.impressions;\n        const n2 = treatmentMetrics.impressions;\n\n        const pooledP = (controlMetrics.conversions + treatmentMetrics.conversions) / (n1 + n2);\n        const se = Math.sqrt(pooledP * (1 - pooledP) * (1 / n1 + 1 / n2));\n        const z = (p2 - p1) / se;\n        pValue = 2 * (1 - this.normalCDF(Math.abs(z)));\n        estimatedEffect = ((p2 - p1) / p1) * 100;\n        break;\n\n      case 'chi_square':\n        // Chi-square test\n        const observed = [\n          [controlMetrics.conversions, controlMetrics.impressions - controlMetrics.conversions],\n          [treatmentMetrics.conversions, treatmentMetrics.impressions - treatmentMetrics.conversions],\n        ];\n        const chiSquare = this.calculateChiSquare(observed);\n        pValue = 1 - this.chiSquareCDF(chiSquare, 1);\n        estimatedEffect = ((treatmentMetrics.conversionRate - controlMetrics.conversionRate) / controlMetrics.conversionRate) * 100;\n        break;\n\n      case 'ttest':\n        // T-test for means\n        pValue = 0.05; // Simplified\n        estimatedEffect = ((treatmentMetrics.revenue || 0) - (controlMetrics.revenue || 0)) / Math.max(controlMetrics.revenue || 1, 1) * 100;\n        break;\n    }\n\n    const isSignificant = pValue < 1 - confidenceLevel;\n    const zScore = this.inverseNormalCDF(1 - (1 - confidenceLevel) / 2);\n    const marginOfError = zScore * Math.sqrt((controlMetrics.conversionRate * (100 - controlMetrics.conversionRate)) / controlMetrics.impressions);\n\n    return {\n      variantId: '',\n      metrics: { ...treatmentMetrics },\n      statisticalSignificance: pValue,\n      isSignificant,\n      confidenceInterval: {\n        lower: treatmentMetrics.conversionRate - marginOfError,\n        upper: treatmentMetrics.conversionRate + marginOfError,\n      },\n      estimatedEffect,\n    };\n  }\n\n  /**\n   * Normal CDF approximation\n   */\n  private normalCDF(z: number): number {\n    const a1 = 0.254829592;\n    const a2 = -0.284496736;\n    const a3 = 1.421413741;\n    const a4 = -1.453152027;\n    const a5 = 1.061405429;\n    const p = 0.3275911;\n\n    const sign = z < 0 ? -1 : 1;\n    z = Math.abs(z) / Math.sqrt(2);\n\n    const t = 1.0 / (1.0 + p * z);\n    const y = 1.0 - (((((a5 * t + a4) * t + a3) * t + a2) * t + a1) * t) * Math.exp(-z * z);\n\n    return 0.5 * (1.0 + sign * y);\n  }\n\n  /**\n   * Inverse normal CDF\n   */\n  private inverseNormalCDF(p: number): number {\n    // Approximation of inverse normal CDF\n    if (p < 0.5) {\n      return -this.inverseNormalCDF(1 - p);\n    }\n\n    const c = [2.515517, 0.802853, 0.010328];\n    const d = [1.432788, 0.189269, 0.001308];\n\n    const t = Math.sqrt(-2.0 * Math.log(1.0 - p));\n    return t - ((c[2] * t + c[1]) * t + c[0]) / (((d[2] * t + d[1]) * t + d[0]) * t + 1.0);\n  }\n\n  /**\n   * Chi-square CDF approximation\n   */\n  private chiSquareCDF(x: number, df: number): number {\n    // Simplified chi-square CDF\n    return 1 - Math.exp(-x / 2) * Math.pow(x / 2, df / 2 - 1) / this.factorial(df / 2 - 1);\n  }\n\n  /**\n   * Calculate chi-square statistic\n   */\n  private calculateChiSquare(observed: number[][]): number {\n    let chiSquare = 0;\n    const rowTotals = observed.map((row) => row.reduce((a, b) => a + b, 0));\n    const colTotals = [0, 0];\n    const total = rowTotals.reduce((a, b) => a + b, 0);\n\n    for (let j = 0; j < 2; j++) {\n      for (let i = 0; i < 2; i++) {\n        colTotals[j] += observed[i][j];\n      }\n    }\n\n    for (let i = 0; i < 2; i++) {\n      for (let j = 0; j < 2; j++) {\n        const expected = (rowTotals[i] * colTotals[j]) / total;\n        chiSquare += Math.pow(observed[i][j] - expected, 2) / expected;\n      }\n    }\n\n    return chiSquare;\n  }\n\n  /**\n   * Factorial\n   */\n  private factorial(n: number): number {\n    if (n <= 1) return 1;\n    return n * this.factorial(n - 1);\n  }\n\n  /**\n   * Complete test\n   */\n  completeTest(testId: string): boolean {\n    const test = this.tests.get(testId);\n    if (!test) return false;\n\n    test.status = 'completed';\n    test.endDate = Date.now();\n    test.updatedAt = Date.now();\n    this.statistics.runningTests--;\n    this.statistics.completedTests++;\n\n    // Calculate test duration\n    const duration = test.endDate - test.startDate;\n    this.testDurations.push(duration);\n\n    // Check for significant results\n    const results = this.results.get(testId) || [];\n    const significantCount = results.filter((r) => r.isSignificant).length;\n    this.statistics.significantResults += significantCount;\n\n    this.emit('test:completed', { testId, results });\n    return true;\n  }\n\n  /**\n   * Get test\n   */\n  getTest(testId: string): ABTest | undefined {\n    return this.tests.get(testId);\n  }\n\n  /**\n   * List tests\n   */\n  listTests(status?: TestStatus): ABTest[] {\n    const tests = Array.from(this.tests.values());\n\n    if (status) {\n      return tests.filter((t) => t.status === status);\n    }\n\n    return tests;\n  }\n\n  /**\n   * Get statistics\n   */\n  getStatistics(): ABTestStatistics {\n    if (this.testDurations.length > 0) {\n      this.statistics.averageTestDuration =\n        this.testDurations.reduce((a, b) => a + b, 0) / this.testDurations.length;\n    }\n\n    return { ...this.statistics };\n  }\n}\n\nexport default ABTestingFramework;\n
