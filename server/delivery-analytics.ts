import { EventEmitter } from 'events';\n\nexport type AnalyticsMetricType =\n  | 'delivery_rate'\n  | 'open_rate'\n  | 'click_rate'\n  | 'conversion_rate'\n  | 'bounce_rate'\n  | 'unsubscribe_rate'\n  | 'engagement_score';\n\nexport type TimeGranularity = 'hourly' | 'daily' | 'weekly' | 'monthly';\n\nexport interface DeliveryEvent {\n  id: string;\n  notificationId: string;\n  userId: string;\n  eventType: 'sent' | 'delivered' | 'opened' | 'clicked' | 'converted' | 'bounced' | 'unsubscribed';\n  timestamp: number;\n  metadata?: Record<string, any>;\n}\n\nexport interface NotificationAnalytics {\n  notificationId: string;\n  totalSent: number;\n  totalDelivered: number;\n  totalOpened: number;\n  totalClicked: number;\n  totalConverted: number;\n  totalBounced: number;\n  totalUnsubscribed: number;\n  deliveryRate: number;\n  openRate: number;\n  clickRate: number;\n  conversionRate: number;\n  bounceRate: number;\n  unsubscribeRate: number;\n  averageTimeToOpen: number;\n  averageTimeToClick: number;\n  engagementScore: number;\n}\n\nexport interface UserEngagementProfile {\n  userId: string;\n  totalNotificationsReceived: number;\n  totalNotificationsOpened: number;\n  totalNotificationsClicked: number;\n  totalConversions: number;\n  averageOpenRate: number;\n  averageClickRate: number;\n  averageConversionRate: number;\n  engagementTrend: 'increasing' | 'decreasing' | 'stable';\n  lastEngagementAt: number;\n  preferredChannels: Record<string, number>; // channel -> score\n  preferredTimes: Record<number, number>; // hour -> score\n}\n\nexport interface TimeSeriesData {\n  timestamp: number;\n  value: number;\n  metadata?: Record<string, any>;\n}\n\nexport interface AnalyticsReport {\n  id: string;\n  name: string;\n  reportType: 'summary' | 'detailed' | 'comparative' | 'trend';\n  startDate: number;\n  endDate: number;\n  metrics: Record<string, number>;\n  timeSeriesData: Record<string, TimeSeriesData[]>;\n  insights: string[];\n  generatedAt: number;\n}\n\nexport interface AnalyticsStatistics {\n  totalEvents: number;\n  totalNotifications: number;\n  averageDeliveryRate: number;\n  averageOpenRate: number;\n  averageClickRate: number;\n  averageConversionRate: number;\n  topPerformingNotifications: Array<{ id: string; engagementScore: number }>;\n  topEngagedUsers: Array<{ userId: string; engagementScore: number }>;\n}\n\nclass NotificationDeliveryAnalytics extends EventEmitter {\n  private events: Map<string, DeliveryEvent> = new Map();\n  private eventLog: DeliveryEvent[] = [];\n  private notificationAnalytics: Map<string, NotificationAnalytics> = new Map();\n  private userProfiles: Map<string, UserEngagementProfile> = new Map();\n  private timeSeries: Map<string, TimeSeriesData[]> = new Map();\n  private reports: Map<string, AnalyticsReport> = new Map();\n  private statistics: AnalyticsStatistics = {\n    totalEvents: 0,\n    totalNotifications: 0,\n    averageDeliveryRate: 0,\n    averageOpenRate: 0,\n    averageClickRate: 0,\n    averageConversionRate: 0,\n    topPerformingNotifications: [],\n    topEngagedUsers: [],\n  };\n  private maxLogSize: number = 1000000;\n  private aggregationInterval: number = 60000; // 1 minute\n\n  constructor() {\n    super();\n    this.startAggregation();\n  }\n\n  /**\n   * Record delivery event\n   */\n  recordEvent(\n    notificationId: string,\n    userId: string,\n    eventType: DeliveryEvent['eventType'],\n    metadata?: Record<string, any>\n  ): DeliveryEvent {\n    const event: DeliveryEvent = {\n      id: `event-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,\n      notificationId,\n      userId,\n      eventType,\n      timestamp: Date.now(),\n      metadata,\n    };\n\n    this.events.set(event.id, event);\n    this.eventLog.push(event);\n\n    // Maintain max log size\n    if (this.eventLog.length > this.maxLogSize) {\n      const removed = this.eventLog.shift();\n      if (removed) {\n        this.events.delete(removed.id);\n      }\n    }\n\n    // Update notification analytics\n    this.updateNotificationAnalytics(notificationId, eventType);\n\n    // Update user profile\n    this.updateUserProfile(userId, eventType);\n\n    // Record time series\n    this.recordTimeSeries(`event_${eventType}`, 1);\n\n    this.statistics.totalEvents++;\n    this.emit('event:recorded', event);\n\n    return event;\n  }\n\n  /**\n   * Update notification analytics\n   */\n  private updateNotificationAnalytics(notificationId: string, eventType: string): void {\n    if (!this.notificationAnalytics.has(notificationId)) {\n      this.notificationAnalytics.set(notificationId, {\n        notificationId,\n        totalSent: 0,\n        totalDelivered: 0,\n        totalOpened: 0,\n        totalClicked: 0,\n        totalConverted: 0,\n        totalBounced: 0,\n        totalUnsubscribed: 0,\n        deliveryRate: 0,\n        openRate: 0,\n        clickRate: 0,\n        conversionRate: 0,\n        bounceRate: 0,\n        unsubscribeRate: 0,\n        averageTimeToOpen: 0,\n        averageTimeToClick: 0,\n        engagementScore: 0,\n      });\n    }\n\n    const analytics = this.notificationAnalytics.get(notificationId)!;\n\n    switch (eventType) {\n      case 'sent':\n        analytics.totalSent++;\n        break;\n      case 'delivered':\n        analytics.totalDelivered++;\n        break;\n      case 'opened':\n        analytics.totalOpened++;\n        break;\n      case 'clicked':\n        analytics.totalClicked++;\n        break;\n      case 'converted':\n        analytics.totalConverted++;\n        break;\n      case 'bounced':\n        analytics.totalBounced++;\n        break;\n      case 'unsubscribed':\n        analytics.totalUnsubscribed++;\n        break;\n    }\n\n    // Calculate rates\n    analytics.deliveryRate = (analytics.totalDelivered / Math.max(analytics.totalSent, 1)) * 100;\n    analytics.openRate = (analytics.totalOpened / Math.max(analytics.totalDelivered, 1)) * 100;\n    analytics.clickRate = (analytics.totalClicked / Math.max(analytics.totalOpened, 1)) * 100;\n    analytics.conversionRate = (analytics.totalConverted / Math.max(analytics.totalClicked, 1)) * 100;\n    analytics.bounceRate = (analytics.totalBounced / Math.max(analytics.totalSent, 1)) * 100;\n    analytics.unsubscribeRate = (analytics.totalUnsubscribed / Math.max(analytics.totalDelivered, 1)) * 100;\n\n    // Calculate engagement score (0-100)\n    analytics.engagementScore =\n      (analytics.openRate * 0.3 + analytics.clickRate * 0.4 + analytics.conversionRate * 0.3) / 100;\n  }\n\n  /**\n   * Update user profile\n   */\n  private updateUserProfile(userId: string, eventType: string): void {\n    if (!this.userProfiles.has(userId)) {\n      this.userProfiles.set(userId, {\n        userId,\n        totalNotificationsReceived: 0,\n        totalNotificationsOpened: 0,\n        totalNotificationsClicked: 0,\n        totalConversions: 0,\n        averageOpenRate: 0,\n        averageClickRate: 0,\n        averageConversionRate: 0,\n        engagementTrend: 'stable',\n        lastEngagementAt: Date.now(),\n        preferredChannels: {},\n        preferredTimes: {},\n      });\n    }\n\n    const profile = this.userProfiles.get(userId)!;\n\n    switch (eventType) {\n      case 'delivered':\n        profile.totalNotificationsReceived++;\n        break;\n      case 'opened':\n        profile.totalNotificationsOpened++;\n        profile.lastEngagementAt = Date.now();\n        break;\n      case 'clicked':\n        profile.totalNotificationsClicked++;\n        profile.lastEngagementAt = Date.now();\n        break;\n      case 'converted':\n        profile.totalConversions++;\n        profile.lastEngagementAt = Date.now();\n        break;\n    }\n\n    // Calculate rates\n    profile.averageOpenRate =\n      (profile.totalNotificationsOpened / Math.max(profile.totalNotificationsReceived, 1)) * 100;\n    profile.averageClickRate =\n      (profile.totalNotificationsClicked / Math.max(profile.totalNotificationsOpened, 1)) * 100;\n    profile.averageConversionRate =\n      (profile.totalConversions / Math.max(profile.totalNotificationsClicked, 1)) * 100;\n  }\n\n  /**\n   * Record time series data\n   */\n  private recordTimeSeries(key: string, value: number): void {\n    if (!this.timeSeries.has(key)) {\n      this.timeSeries.set(key, []);\n    }\n\n    const series = this.timeSeries.get(key)!;\n    series.push({\n      timestamp: Date.now(),\n      value,\n    });\n\n    // Keep last 10000 data points\n    if (series.length > 10000) {\n      series.shift();\n    }\n  }\n\n  /**\n   * Get notification analytics\n   */\n  getNotificationAnalytics(notificationId: string): NotificationAnalytics | undefined {\n    return this.notificationAnalytics.get(notificationId);\n  }\n\n  /**\n   * Get user engagement profile\n   */\n  getUserEngagementProfile(userId: string): UserEngagementProfile | undefined {\n    return this.userProfiles.get(userId);\n  }\n\n  /**\n   * Get events for notification\n   */\n  getNotificationEvents(notificationId: string): DeliveryEvent[] {\n    return this.eventLog.filter((e) => e.notificationId === notificationId);\n  }\n\n  /**\n   * Get events for user\n   */\n  getUserEvents(userId: string, limit: number = 1000): DeliveryEvent[] {\n    return this.eventLog.filter((e) => e.userId === userId).slice(-limit);\n  }\n\n  /**\n   * Generate analytics report\n   */\n  generateReport(\n    name: string,\n    reportType: AnalyticsReport['reportType'],\n    startDate: number,\n    endDate: number,\n    filters?: Record<string, any>\n  ): AnalyticsReport {\n    const report: AnalyticsReport = {\n      id: `report-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,\n      name,\n      reportType,\n      startDate,\n      endDate,\n      metrics: {},\n      timeSeriesData: {},\n      insights: [],\n      generatedAt: Date.now(),\n    };\n\n    // Filter events by date range\n    const filteredEvents = this.eventLog.filter(\n      (e) => e.timestamp >= startDate && e.timestamp <= endDate\n    );\n\n    // Calculate metrics\n    const eventCounts: Record<string, number> = {};\n    for (const event of filteredEvents) {\n      eventCounts[event.eventType] = (eventCounts[event.eventType] || 0) + 1;\n    }\n\n    report.metrics = {\n      totalEvents: filteredEvents.length,\n      sent: eventCounts['sent'] || 0,\n      delivered: eventCounts['delivered'] || 0,\n      opened: eventCounts['opened'] || 0,\n      clicked: eventCounts['clicked'] || 0,\n      converted: eventCounts['converted'] || 0,\n      bounced: eventCounts['bounced'] || 0,\n      unsubscribed: eventCounts['unsubscribed'] || 0,\n    };\n\n    // Calculate rates\n    const sent = report.metrics['sent'] || 1;\n    const delivered = report.metrics['delivered'] || 0;\n    const opened = report.metrics['opened'] || 0;\n    const clicked = report.metrics['clicked'] || 0;\n    const converted = report.metrics['converted'] || 0;\n\n    report.metrics['deliveryRate'] = (delivered / sent) * 100;\n    report.metrics['openRate'] = (opened / Math.max(delivered, 1)) * 100;\n    report.metrics['clickRate'] = (clicked / Math.max(opened, 1)) * 100;\n    report.metrics['conversionRate'] = (converted / Math.max(clicked, 1)) * 100;\n\n    // Generate insights\n    report.insights = this.generateInsights(report.metrics);\n\n    this.reports.set(report.id, report);\n    this.emit('report:generated', report);\n\n    return report;\n  }\n\n  /**\n   * Generate insights\n   */\n  private generateInsights(metrics: Record<string, number>): string[] {\n    const insights: string[] = [];\n\n    if (metrics['deliveryRate'] < 90) {\n      insights.push('Delivery rate is below 90%. Consider reviewing sender reputation.');\n    }\n\n    if (metrics['openRate'] > 40) {\n      insights.push('High open rate detected. Subject lines and timing are effective.');\n    }\n\n    if (metrics['clickRate'] > 10) {\n      insights.push('Strong click-through rate. Call-to-action is resonating well.');\n    }\n\n    if (metrics['conversionRate'] > 5) {\n      insights.push('Excellent conversion rate. Campaign messaging is highly effective.');\n    }\n\n    if (metrics['bounceRate'] > 5) {\n      insights.push('High bounce rate detected. Review email list quality.');\n    }\n\n    if (metrics['unsubscribeRate'] > 1) {\n      insights.push('Unsubscribe rate is elevated. Consider content relevance.');\n    }\n\n    return insights;\n  }\n\n  /**\n   * Get time series data\n   */\n  getTimeSeriesData(key: string, granularity: TimeGranularity = 'hourly'): TimeSeriesData[] {\n    const data = this.timeSeries.get(key) || [];\n    return this.aggregateTimeSeries(data, granularity);\n  }\n\n  /**\n   * Aggregate time series\n   */\n  private aggregateTimeSeries(data: TimeSeriesData[], granularity: TimeGranularity): TimeSeriesData[] {\n    if (data.length === 0) return [];\n\n    const interval = this.getGranularityInterval(granularity);\n    const aggregated: Map<number, number> = new Map();\n\n    for (const point of data) {\n      const bucket = Math.floor(point.timestamp / interval) * interval;\n      aggregated.set(bucket, (aggregated.get(bucket) || 0) + point.value);\n    }\n\n    return Array.from(aggregated.entries()).map(([timestamp, value]) => ({\n      timestamp,\n      value,\n    }));\n  }\n\n  /**\n   * Get granularity interval\n   */\n  private getGranularityInterval(granularity: TimeGranularity): number {\n    switch (granularity) {\n      case 'hourly':\n        return 60 * 60 * 1000;\n      case 'daily':\n        return 24 * 60 * 60 * 1000;\n      case 'weekly':\n        return 7 * 24 * 60 * 60 * 1000;\n      case 'monthly':\n        return 30 * 24 * 60 * 60 * 1000;\n    }\n  }\n\n  /**\n   * Start aggregation\n   */\n  private startAggregation(): void {\n    setInterval(() => {\n      this.updateStatistics();\n    }, this.aggregationInterval);\n  }\n\n  /**\n   * Update statistics\n   */\n  private updateStatistics(): void {\n    this.statistics.totalNotifications = this.notificationAnalytics.size;\n\n    let totalDeliveryRate = 0;\n    let totalOpenRate = 0;\n    let totalClickRate = 0;\n    let totalConversionRate = 0;\n    let count = 0;\n\n    for (const analytics of this.notificationAnalytics.values()) {\n      totalDeliveryRate += analytics.deliveryRate;\n      totalOpenRate += analytics.openRate;\n      totalClickRate += analytics.clickRate;\n      totalConversionRate += analytics.conversionRate;\n      count++;\n    }\n\n    if (count > 0) {\n      this.statistics.averageDeliveryRate = totalDeliveryRate / count;\n      this.statistics.averageOpenRate = totalOpenRate / count;\n      this.statistics.averageClickRate = totalClickRate / count;\n      this.statistics.averageConversionRate = totalConversionRate / count;\n    }\n\n    // Top performing notifications\n    const sorted = Array.from(this.notificationAnalytics.values())\n      .sort((a, b) => b.engagementScore - a.engagementScore)\n      .slice(0, 5);\n    this.statistics.topPerformingNotifications = sorted.map((a) => ({\n      id: a.notificationId,\n      engagementScore: a.engagementScore,\n    }));\n\n    // Top engaged users\n    const userSorted = Array.from(this.userProfiles.values())\n      .sort((a, b) => (b.averageOpenRate + b.averageClickRate) - (a.averageOpenRate + a.averageClickRate))\n      .slice(0, 5);\n    this.statistics.topEngagedUsers = userSorted.map((p) => ({\n      userId: p.userId,\n      engagementScore: (p.averageOpenRate + p.averageClickRate) / 2,\n    }));\n  }\n\n  /**\n   * Get statistics\n   */\n  getStatistics(): AnalyticsStatistics {\n    this.updateStatistics();\n    return { ...this.statistics };\n  }\n\n  /**\n   * Export analytics\n   */\n  exportAnalytics(format: 'csv' | 'json' = 'json'): string {\n    const data = {\n      statistics: this.statistics,\n      notifications: Array.from(this.notificationAnalytics.values()),\n      users: Array.from(this.userProfiles.values()),\n      exportedAt: Date.now(),\n    };\n\n    if (format === 'json') {\n      return JSON.stringify(data, null, 2);\n    }\n\n    // CSV format\n    const rows: string[] = [];\n    rows.push('NotificationId,TotalSent,TotalDelivered,TotalOpened,TotalClicked,DeliveryRate,OpenRate,ClickRate,EngagementScore');\n\n    for (const analytics of this.notificationAnalytics.values()) {\n      rows.push(\n        `${analytics.notificationId},${analytics.totalSent},${analytics.totalDelivered},${analytics.totalOpened},${analytics.totalClicked},${analytics.deliveryRate.toFixed(2)},${analytics.openRate.toFixed(2)},${analytics.clickRate.toFixed(2)},${analytics.engagementScore.toFixed(2)}`\n      );\n    }\n\n    return rows.join('\\n');\n  }\n}\n\nexport default NotificationDeliveryAnalytics;\n
