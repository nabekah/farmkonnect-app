import { EventEmitter } from 'events';\n\nexport type ScheduleFrequency = 'once' | 'daily' | 'weekly' | 'monthly' | 'custom';\nexport type DayOfWeek = 'monday' | 'tuesday' | 'wednesday' | 'thursday' | 'friday' | 'saturday' | 'sunday';\n\nexport interface ScheduleRule {\n  frequency: ScheduleFrequency;\n  time: string; // HH:mm format\n  timezone: string; // e.g., 'America/New_York'\n  daysOfWeek?: DayOfWeek[];\n  dayOfMonth?: number;\n  endDate?: number; // Unix timestamp\n  maxOccurrences?: number;\n}\n\nexport interface SendTimeOptimization {\n  enabled: boolean;\n  strategy: 'engagement_based' | 'timezone_based' | 'activity_based' | 'ml_predicted';\n  lookbackDays: number;\n  timeWindow: {\n    start: string; // HH:mm\n    end: string; // HH:mm\n  };\n}\n\nexport interface CampaignSchedule {\n  id: string;\n  campaignId: string;\n  scheduleRule: ScheduleRule;\n  sendTimeOptimization?: SendTimeOptimization;\n  nextScheduledTime?: number;\n  lastSentTime?: number;\n  occurrences: number;\n  status: 'active' | 'paused' | 'completed' | 'failed';\n  createdAt: number;\n  updatedAt: number;\n}\n\nexport interface ScheduledSend {\n  id: string;\n  scheduleId: string;\n  campaignId: string;\n  scheduledTime: number;\n  actualSendTime?: number;\n  status: 'pending' | 'processing' | 'sent' | 'failed';\n  recipientCount: number;\n  sentCount: number;\n  failedCount: number;\n  errorMessage?: string;\n}\n\nexport interface OptimalSendTime {\n  recipientId: string;\n  email: string;\n  optimalTime: number; // Unix timestamp\n  confidence: number; // 0-100\n  reason: string;\n}\n\nexport interface ScheduleConflict {\n  scheduleId: string;\n  conflictingScheduleId: string;\n  conflictTime: number;\n  severity: 'low' | 'medium' | 'high';\n  message: string;\n}\n\nclass CampaignScheduler extends EventEmitter {\n  private schedules: Map<string, CampaignSchedule> = new Map();\n  private scheduledSends: Map<string, ScheduledSend> = new Map();\n  private schedulerInterval: NodeJS.Timeout | null = null;\n  private engagementHistory: Map<string, { opens: number; clicks: number; timestamp: number }[]> = new Map();\n\n  constructor() {\n    super();\n    this.startScheduler();\n  }\n\n  /**\n   * Create campaign schedule\n   */\n  createSchedule(\n    campaignId: string,\n    scheduleRule: ScheduleRule,\n    sendTimeOptimization?: SendTimeOptimization\n  ): CampaignSchedule {\n    const schedule: CampaignSchedule = {\n      id: `sch-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,\n      campaignId,\n      scheduleRule,\n      sendTimeOptimization,\n      nextScheduledTime: this.calculateNextScheduledTime(scheduleRule),\n      occurrences: 0,\n      status: 'active',\n      createdAt: Date.now(),\n      updatedAt: Date.now(),\n    };\n\n    this.schedules.set(schedule.id, schedule);\n    this.emit('schedule:created', schedule);\n    return schedule;\n  }\n\n  /**\n   * Get schedule\n   */\n  getSchedule(scheduleId: string): CampaignSchedule | undefined {\n    return this.schedules.get(scheduleId);\n  }\n\n  /**\n   * Get schedules for campaign\n   */\n  getSchedulesForCampaign(campaignId: string): CampaignSchedule[] {\n    return Array.from(this.schedules.values()).filter(\n      (s) => s.campaignId === campaignId\n    );\n  }\n\n  /**\n   * Update schedule\n   */\n  updateSchedule(\n    scheduleId: string,\n    updates: Partial<CampaignSchedule>\n  ): boolean {\n    const schedule = this.schedules.get(scheduleId);\n    if (!schedule) return false;\n\n    Object.assign(schedule, updates, { updatedAt: Date.now() });\n    this.emit('schedule:updated', schedule);\n    return true;\n  }\n\n  /**\n   * Pause schedule\n   */\n  pauseSchedule(scheduleId: string): boolean {\n    const schedule = this.schedules.get(scheduleId);\n    if (!schedule) return false;\n\n    schedule.status = 'paused';\n    schedule.updatedAt = Date.now();\n    this.emit('schedule:paused', schedule);\n    return true;\n  }\n\n  /**\n   * Resume schedule\n   */\n  resumeSchedule(scheduleId: string): boolean {\n    const schedule = this.schedules.get(scheduleId);\n    if (!schedule) return false;\n\n    schedule.status = 'active';\n    schedule.nextScheduledTime = this.calculateNextScheduledTime(schedule.scheduleRule);\n    schedule.updatedAt = Date.now();\n    this.emit('schedule:resumed', schedule);\n    return true;\n  }\n\n  /**\n   * Delete schedule\n   */\n  deleteSchedule(scheduleId: string): boolean {\n    const schedule = this.schedules.get(scheduleId);\n    if (!schedule) return false;\n\n    this.schedules.delete(scheduleId);\n    this.emit('schedule:deleted', { scheduleId });\n    return true;\n  }\n\n  /**\n   * Calculate next scheduled time\n   */\n  private calculateNextScheduledTime(rule: ScheduleRule): number {\n    const now = new Date();\n    const [hours, minutes] = rule.time.split(':').map(Number);\n\n    let nextTime = new Date();\n    nextTime.setHours(hours, minutes, 0, 0);\n\n    // If the time has already passed today, move to next occurrence\n    if (nextTime <= now) {\n      switch (rule.frequency) {\n        case 'once':\n          return nextTime.getTime(); // Already passed\n        case 'daily':\n          nextTime.setDate(nextTime.getDate() + 1);\n          break;\n        case 'weekly':\n          if (rule.daysOfWeek && rule.daysOfWeek.length > 0) {\n            const dayMap = {\n              monday: 1,\n              tuesday: 2,\n              wednesday: 3,\n              thursday: 4,\n              friday: 5,\n              saturday: 6,\n              sunday: 0,\n            };\n            const targetDays = rule.daysOfWeek.map((d) => dayMap[d]);\n            let daysToAdd = 1;\n            while (!targetDays.includes(nextTime.getDay())) {\n              nextTime.setDate(nextTime.getDate() + 1);\n              daysToAdd++;\n              if (daysToAdd > 7) break; // Safety check\n            }\n          } else {\n            nextTime.setDate(nextTime.getDate() + 7);\n          }\n          break;\n        case 'monthly':\n          const targetDay = rule.dayOfMonth || 1;\n          nextTime.setMonth(nextTime.getMonth() + 1);\n          nextTime.setDate(targetDay);\n          break;\n      }\n    }\n\n    // Check end date\n    if (rule.endDate && nextTime.getTime() > rule.endDate) {\n      return rule.endDate;\n    }\n\n    return nextTime.getTime();\n  }\n\n  /**\n   * Calculate optimal send times for recipients\n   */\n  calculateOptimalSendTimes(\n    scheduleId: string,\n    recipients: Array<{ id: string; email: string }>\n  ): OptimalSendTime[] {\n    const schedule = this.schedules.get(scheduleId);\n    if (!schedule || !schedule.sendTimeOptimization?.enabled) return [];\n\n    const optimalTimes: OptimalSendTime[] = [];\n    const strategy = schedule.sendTimeOptimization.strategy;\n\n    for (const recipient of recipients) {\n      let optimalTime = schedule.nextScheduledTime || Date.now();\n      let confidence = 50;\n      let reason = 'Default scheduled time';\n\n      switch (strategy) {\n        case 'engagement_based':\n          const engagementData = this.engagementHistory.get(recipient.id);\n          if (engagementData && engagementData.length > 0) {\n            const avgHour = this.calculateAverageEngagementHour(engagementData);\n            optimalTime = this.adjustTimeToHour(optimalTime, avgHour);\n            confidence = Math.min(100, 50 + engagementData.length * 5);\n            reason = `Based on ${engagementData.length} engagement events`;\n          }\n          break;\n\n        case 'timezone_based':\n          // Adjust for recipient timezone (would need timezone data)\n          confidence = 70;\n          reason = 'Adjusted for recipient timezone';\n          break;\n\n        case 'activity_based':\n          // Adjust based on recent activity\n          confidence = 65;\n          reason = 'Based on recent activity patterns';\n          break;\n\n        case 'ml_predicted':\n          // ML-based prediction (simulated)\n          confidence = 85;\n          reason = 'ML model prediction';\n          break;\n      }\n\n      optimalTimes.push({\n        recipientId: recipient.id,\n        email: recipient.email,\n        optimalTime,\n        confidence,\n        reason,\n      });\n    }\n\n    return optimalTimes;\n  }\n\n  /**\n   * Calculate average engagement hour\n   */\n  private calculateAverageEngagementHour(data: { opens: number; clicks: number; timestamp: number }[]): number {\n    if (data.length === 0) return 12; // Default to noon\n\n    const hours = data.map((d) => new Date(d.timestamp).getHours());\n    const sum = hours.reduce((a, b) => a + b, 0);\n    return Math.round(sum / hours.length);\n  }\n\n  /**\n   * Adjust time to specific hour\n   */\n  private adjustTimeToHour(baseTime: number, hour: number): number {\n    const date = new Date(baseTime);\n    date.setHours(hour, Math.random() * 60, 0, 0);\n    return date.getTime();\n  }\n\n  /**\n   * Record engagement for optimization\n   */\n  recordEngagement(recipientId: string, opens: number, clicks: number): void {\n    if (!this.engagementHistory.has(recipientId)) {\n      this.engagementHistory.set(recipientId, []);\n    }\n\n    const history = this.engagementHistory.get(recipientId)!;\n    history.push({ opens, clicks, timestamp: Date.now() });\n\n    // Keep last 30 days\n    const thirtyDaysAgo = Date.now() - 30 * 24 * 60 * 60 * 1000;\n    const filtered = history.filter((h) => h.timestamp > thirtyDaysAgo);\n    this.engagementHistory.set(recipientId, filtered);\n  }\n\n  /**\n   * Create scheduled send\n   */\n  createScheduledSend(\n    scheduleId: string,\n    campaignId: string,\n    recipientCount: number\n  ): ScheduledSend {\n    const schedule = this.schedules.get(scheduleId);\n    if (!schedule) throw new Error('Schedule not found');\n\n    const send: ScheduledSend = {\n      id: `send-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,\n      scheduleId,\n      campaignId,\n      scheduledTime: schedule.nextScheduledTime || Date.now(),\n      status: 'pending',\n      recipientCount,\n      sentCount: 0,\n      failedCount: 0,\n    };\n\n    this.scheduledSends.set(send.id, send);\n    this.emit('send:scheduled', send);\n    return send;\n  }\n\n  /**\n   * Get scheduled send\n   */\n  getScheduledSend(sendId: string): ScheduledSend | undefined {\n    return this.scheduledSends.get(sendId);\n  }\n\n  /**\n   * Update scheduled send\n   */\n  updateScheduledSend(sendId: string, updates: Partial<ScheduledSend>): boolean {\n    const send = this.scheduledSends.get(sendId);\n    if (!send) return false;\n\n    Object.assign(send, updates);\n    this.emit('send:updated', send);\n    return true;\n  }\n\n  /**\n   * Get pending sends\n   */\n  getPendingSends(): ScheduledSend[] {\n    return Array.from(this.scheduledSends.values()).filter(\n      (s) => s.status === 'pending' || s.status === 'processing'\n    );\n  }\n\n  /**\n   * Check for schedule conflicts\n   */\n  checkConflicts(scheduleId: string): ScheduleConflict[] {\n    const schedule = this.schedules.get(scheduleId);\n    if (!schedule) return [];\n\n    const conflicts: ScheduleConflict[] = [];\n    const nextTime = schedule.nextScheduledTime || Date.now();\n    const timeWindow = 60 * 60 * 1000; // 1 hour window\n\n    for (const [otherId, otherSchedule] of this.schedules) {\n      if (otherId === scheduleId) continue;\n      if (otherSchedule.status !== 'active') continue;\n\n      const otherTime = otherSchedule.nextScheduledTime || Date.now();\n      const timeDiff = Math.abs(nextTime - otherTime);\n\n      if (timeDiff < timeWindow) {\n        const severity = timeDiff < 5 * 60 * 1000 ? 'high' : 'medium';\n        conflicts.push({\n          scheduleId,\n          conflictingScheduleId: otherId,\n          conflictTime: nextTime,\n          severity,\n          message: `Conflict with campaign ${otherSchedule.campaignId} scheduled at ${new Date(otherTime).toISOString()}`,\n        });\n      }\n    }\n\n    return conflicts;\n  }\n\n  /**\n   * Start scheduler\n   */\n  private startScheduler(): void {\n    this.schedulerInterval = setInterval(() => {\n      this.processSchedules();\n    }, 60 * 1000); // Check every minute\n  }\n\n  /**\n   * Process schedules\n   */\n  private processSchedules(): void {\n    const now = Date.now();\n\n    for (const [scheduleId, schedule] of this.schedules) {\n      if (schedule.status !== 'active') continue;\n      if (!schedule.nextScheduledTime || schedule.nextScheduledTime > now) continue;\n\n      // Check if max occurrences reached\n      if (schedule.scheduleRule.maxOccurrences && schedule.occurrences >= schedule.scheduleRule.maxOccurrences) {\n        schedule.status = 'completed';\n        this.emit('schedule:completed', schedule);\n        continue;\n      }\n\n      // Trigger send\n      this.emit('schedule:trigger', { scheduleId, schedule });\n\n      // Update schedule\n      schedule.lastSentTime = now;\n      schedule.occurrences++;\n      schedule.nextScheduledTime = this.calculateNextScheduledTime(schedule.scheduleRule);\n\n      // Check if schedule is complete\n      if (schedule.scheduleRule.frequency === 'once' || (schedule.scheduleRule.endDate && now > schedule.scheduleRule.endDate)) {\n        schedule.status = 'completed';\n      }\n    }\n  }\n\n  /**\n   * Get schedule statistics\n   */\n  getScheduleStatistics(scheduleId: string): Record<string, any> | null {\n    const schedule = this.schedules.get(scheduleId);\n    if (!schedule) return null;\n\n    const sends = Array.from(this.scheduledSends.values()).filter(\n      (s) => s.scheduleId === scheduleId\n    );\n\n    const totalRecipients = sends.reduce((sum, s) => sum + s.recipientCount, 0);\n    const totalSent = sends.reduce((sum, s) => sum + s.sentCount, 0);\n    const totalFailed = sends.reduce((sum, s) => sum + s.failedCount, 0);\n\n    return {\n      schedule,\n      totalSends: sends.length,\n      totalRecipients,\n      totalSent,\n      totalFailed,\n      successRate: totalRecipients > 0 ? (totalSent / totalRecipients) * 100 : 0,\n      averageRecipientsPerSend: sends.length > 0 ? totalRecipients / sends.length : 0,\n    };\n  }\n\n  /**\n   * Cleanup\n   */\n  destroy(): void {\n    if (this.schedulerInterval) {\n      clearInterval(this.schedulerInterval);\n    }\n  }\n}\n\nexport default CampaignScheduler;\n
