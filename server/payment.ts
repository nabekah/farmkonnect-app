import { EventEmitter } from 'events';\n\nexport type SubscriptionTier = 'free' | 'starter' | 'professional' | 'enterprise';\nexport type PaymentStatus = 'pending' | 'completed' | 'failed' | 'refunded' | 'cancelled';\nexport type PaymentMethod = 'card' | 'bank_transfer' | 'paypal';\n\nexport interface SubscriptionPlan {\n  id: string;\n  tier: SubscriptionTier;\n  name: string;\n  price: number;\n  currency: string;\n  billingCycle: 'monthly' | 'yearly';\n  features: string[];\n  maxFarms: number;\n  maxTeamMembers: number;\n  apiRateLimit: number;\n  storageGB: number;\n}\n\nexport interface PaymentIntent {\n  id: string;\n  userId: string;\n  amount: number;\n  currency: string;\n  status: PaymentStatus;\n  paymentMethod: PaymentMethod;\n  description: string;\n  createdAt: number;\n  completedAt?: number;\n  metadata?: Record<string, any>;\n  receiptUrl?: string;\n  errorMessage?: string;\n}\n\nexport interface Subscription {\n  id: string;\n  userId: string;\n  planId: string;\n  tier: SubscriptionTier;\n  status: 'active' | 'cancelled' | 'expired' | 'past_due';\n  currentPeriodStart: number;\n  currentPeriodEnd: number;\n  cancelledAt?: number;\n  autoRenew: boolean;\n  paymentMethodId?: string;\n}\n\nexport interface Invoice {\n  id: string;\n  userId: string;\n  subscriptionId: string;\n  amount: number;\n  currency: string;\n  status: 'draft' | 'sent' | 'paid' | 'void' | 'uncollectible';\n  issuedAt: number;\n  dueAt: number;\n  paidAt?: number;\n  lineItems: Array<{\n    description: string;\n    quantity: number;\n    unitPrice: number;\n  }>;\n}\n\nexport interface Refund {\n  id: string;\n  paymentIntentId: string;\n  amount: number;\n  reason: string;\n  status: 'pending' | 'succeeded' | 'failed';\n  createdAt: number;\n  processedAt?: number;\n}\n\n/**\n * Payment Manager with Stripe Integration\n */\nexport class PaymentManager extends EventEmitter {\n  private plans: Map<string, SubscriptionPlan> = new Map();\n  private subscriptions: Map<string, Subscription> = new Map();\n  private paymentIntents: Map<string, PaymentIntent> = new Map();\n  private invoices: Map<string, Invoice> = new Map();\n  private refunds: Map<string, Refund> = new Map();\n  private webhookLogs: Array<{ event: string; timestamp: number; data: any }> = [];\n\n  constructor(private stripeApiKey: string = 'sk_test_default') {\n    super();\n    this.initializeDefaultPlans();\n  }\n\n  /**\n   * Initialize default subscription plans\n   */\n  private initializeDefaultPlans(): void {\n    const plans: SubscriptionPlan[] = [\n      {\n        id: 'plan-free',\n        tier: 'free',\n        name: 'Free',\n        price: 0,\n        currency: 'USD',\n        billingCycle: 'monthly',\n        features: ['Basic farm management', '1 farm', '2 team members', 'Email support'],\n        maxFarms: 1,\n        maxTeamMembers: 2,\n        apiRateLimit: 100,\n        storageGB: 5,\n      },\n      {\n        id: 'plan-starter',\n        tier: 'starter',\n        name: 'Starter',\n        price: 29.99,\n        currency: 'USD',\n        billingCycle: 'monthly',\n        features: ['Advanced analytics', '5 farms', '10 team members', 'Priority support', 'Custom reports'],\n        maxFarms: 5,\n        maxTeamMembers: 10,\n        apiRateLimit: 1000,\n        storageGB: 50,\n      },\n      {\n        id: 'plan-professional',\n        tier: 'professional',\n        name: 'Professional',\n        price: 99.99,\n        currency: 'USD',\n        billingCycle: 'monthly',\n        features: ['AI predictions', 'Unlimited farms', '50 team members', '24/7 support', 'API access', 'Webhooks'],\n        maxFarms: 999,\n        maxTeamMembers: 50,\n        apiRateLimit: 10000,\n        storageGB: 500,\n      },\n      {\n        id: 'plan-enterprise',\n        tier: 'enterprise',\n        name: 'Enterprise',\n        price: 0, // Custom pricing\n        currency: 'USD',\n        billingCycle: 'yearly',\n        features: ['Everything in Professional', 'Dedicated support', 'Custom integrations', 'SLA guarantee'],\n        maxFarms: 999,\n        maxTeamMembers: 999,\n        apiRateLimit: 100000,\n        storageGB: 5000,\n      },\n    ];\n\n    for (const plan of plans) {\n      this.plans.set(plan.id, plan);\n    }\n  }\n\n  /**\n   * Get subscription plan\n   */\n  getPlan(planId: string): SubscriptionPlan | null {\n    return this.plans.get(planId) || null;\n  }\n\n  /**\n   * Get all plans\n   */\n  getAllPlans(): SubscriptionPlan[] {\n    return Array.from(this.plans.values());\n  }\n\n  /**\n   * Create payment intent\n   */\n  createPaymentIntent(\n    userId: string,\n    amount: number,\n    currency: string = 'USD',\n    description: string = '',\n    paymentMethod: PaymentMethod = 'card',\n    metadata?: Record<string, any>\n  ): PaymentIntent {\n    const intentId = `pi_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n\n    const intent: PaymentIntent = {\n      id: intentId,\n      userId,\n      amount,\n      currency,\n      status: 'pending',\n      paymentMethod,\n      description,\n      createdAt: Date.now(),\n      metadata,\n    };\n\n    this.paymentIntents.set(intentId, intent);\n    this.emit('payment:intent_created', { intentId, userId, amount });\n    return intent;\n  }\n\n  /**\n   * Process payment\n   */\n  async processPayment(intentId: string): Promise<PaymentIntent> {\n    const intent = this.paymentIntents.get(intentId);\n    if (!intent) throw new Error('Payment intent not found');\n\n    // Simulate Stripe payment processing\n    const success = Math.random() > 0.05; // 95% success rate\n\n    if (success) {\n      intent.status = 'completed';\n      intent.completedAt = Date.now();\n      intent.receiptUrl = `https://receipts.stripe.com/${intentId}`;\n      this.emit('payment:succeeded', { intentId, userId: intent.userId, amount: intent.amount });\n    } else {\n      intent.status = 'failed';\n      intent.errorMessage = 'Card declined';\n      this.emit('payment:failed', { intentId, userId: intent.userId, error: intent.errorMessage });\n    }\n\n    return intent;\n  }\n\n  /**\n   * Create subscription\n   */\n  createSubscription(\n    userId: string,\n    planId: string,\n    paymentMethodId?: string,\n    autoRenew: boolean = true\n  ): Subscription {\n    const plan = this.getPlan(planId);\n    if (!plan) throw new Error('Plan not found');\n\n    const subscriptionId = `sub_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n    const now = Date.now();\n    const periodEnd = plan.billingCycle === 'monthly' ? now + 2592000000 : now + 31536000000;\n\n    const subscription: Subscription = {\n      id: subscriptionId,\n      userId,\n      planId,\n      tier: plan.tier,\n      status: 'active',\n      currentPeriodStart: now,\n      currentPeriodEnd: periodEnd,\n      autoRenew,\n      paymentMethodId,\n    };\n\n    this.subscriptions.set(subscriptionId, subscription);\n    this.emit('subscription:created', { subscriptionId, userId, tier: plan.tier });\n    return subscription;\n  }\n\n  /**\n   * Get subscription\n   */\n  getSubscription(subscriptionId: string): Subscription | null {\n    return this.subscriptions.get(subscriptionId) || null;\n  }\n\n  /**\n   * Get user subscription\n   */\n  getUserSubscription(userId: string): Subscription | null {\n    for (const subscription of this.subscriptions.values()) {\n      if (subscription.userId === userId && subscription.status === 'active') {\n        return subscription;\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Cancel subscription\n   */\n  cancelSubscription(subscriptionId: string, reason?: string): Subscription {\n    const subscription = this.subscriptions.get(subscriptionId);\n    if (!subscription) throw new Error('Subscription not found');\n\n    subscription.status = 'cancelled';\n    subscription.cancelledAt = Date.now();\n    this.emit('subscription:cancelled', { subscriptionId, reason });\n    return subscription;\n  }\n\n  /**\n   * Create invoice\n   */\n  createInvoice(\n    userId: string,\n    subscriptionId: string,\n    lineItems: Array<{ description: string; quantity: number; unitPrice: number }>\n  ): Invoice {\n    const invoiceId = `inv_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n    const now = Date.now();\n    const amount = lineItems.reduce((sum, item) => sum + item.quantity * item.unitPrice, 0);\n\n    const invoice: Invoice = {\n      id: invoiceId,\n      userId,\n      subscriptionId,\n      amount,\n      currency: 'USD',\n      status: 'sent',\n      issuedAt: now,\n      dueAt: now + 2592000000, // 30 days\n      lineItems,\n    };\n\n    this.invoices.set(invoiceId, invoice);\n    this.emit('invoice:created', { invoiceId, userId, amount });\n    return invoice;\n  }\n\n  /**\n   * Get invoice\n   */\n  getInvoice(invoiceId: string): Invoice | null {\n    return this.invoices.get(invoiceId) || null;\n  }\n\n  /**\n   * Get invoices by user\n   */\n  getInvoicesByUser(userId: string): Invoice[] {\n    return Array.from(this.invoices.values()).filter((inv) => inv.userId === userId);\n  }\n\n  /**\n   * Pay invoice\n   */\n  payInvoice(invoiceId: string): Invoice {\n    const invoice = this.invoices.get(invoiceId);\n    if (!invoice) throw new Error('Invoice not found');\n\n    invoice.status = 'paid';\n    invoice.paidAt = Date.now();\n    this.emit('invoice:paid', { invoiceId, amount: invoice.amount });\n    return invoice;\n  }\n\n  /**\n   * Create refund\n   */\n  createRefund(paymentIntentId: string, amount: number, reason: string): Refund {\n    const refundId = `ref_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n\n    const refund: Refund = {\n      id: refundId,\n      paymentIntentId,\n      amount,\n      reason,\n      status: 'pending',\n      createdAt: Date.now(),\n    };\n\n    this.refunds.set(refundId, refund);\n    this.emit('refund:created', { refundId, paymentIntentId, amount });\n    return refund;\n  }\n\n  /**\n   * Process refund\n   */\n  processRefund(refundId: string): Refund {\n    const refund = this.refunds.get(refundId);\n    if (!refund) throw new Error('Refund not found');\n\n    refund.status = 'succeeded';\n    refund.processedAt = Date.now();\n    this.emit('refund:processed', { refundId, amount: refund.amount });\n    return refund;\n  }\n\n  /**\n   * Handle webhook\n   */\n  handleWebhook(event: string, data: any): void {\n    this.webhookLogs.push({ event, timestamp: Date.now(), data });\n    this.emit(`webhook:${event}`, data);\n  }\n\n  /**\n   * Get payment stats\n   */\n  getPaymentStats(): {\n    totalRevenue: number;\n    totalRefunds: number;\n    activeSubscriptions: number;\n    subscriptionsByTier: Record<SubscriptionTier, number>;\n    paymentSuccessRate: number;\n  } {\n    let totalRevenue = 0;\n    let totalRefunds = 0;\n    let activeSubscriptions = 0;\n    const subscriptionsByTier: Record<SubscriptionTier, number> = {\n      free: 0,\n      starter: 0,\n      professional: 0,\n      enterprise: 0,\n    };\n\n    for (const intent of this.paymentIntents.values()) {\n      if (intent.status === 'completed') {\n        totalRevenue += intent.amount;\n      }\n    }\n\n    for (const refund of this.refunds.values()) {\n      if (refund.status === 'succeeded') {\n        totalRefunds += refund.amount;\n      }\n    }\n\n    for (const subscription of this.subscriptions.values()) {\n      if (subscription.status === 'active') {\n        activeSubscriptions++;\n        subscriptionsByTier[subscription.tier]++;\n      }\n    }\n\n    const completedPayments = Array.from(this.paymentIntents.values()).filter(\n      (p) => p.status === 'completed' || p.status === 'failed'\n    ).length;\n    const successfulPayments = Array.from(this.paymentIntents.values()).filter((p) => p.status === 'completed').length;\n    const paymentSuccessRate = completedPayments > 0 ? (successfulPayments / completedPayments) * 100 : 0;\n\n    return {\n      totalRevenue,\n      totalRefunds,\n      activeSubscriptions,\n      subscriptionsByTier,\n      paymentSuccessRate: Math.round(paymentSuccessRate),\n    };\n  }\n}\n
