import { EventEmitter } from 'events';\n\nexport type NotificationType =\n  | 'audit_alert'\n  | 'export_complete'\n  | 'export_failed'\n  | 'sync_started'\n  | 'sync_completed'\n  | 'sync_failed'\n  | 'performance_warning'\n  | 'critical_error'\n  | 'template_shared'\n  | 'comment_added'\n  | 'permission_changed'\n  | 'system_maintenance';\n\nexport type NotificationPriority = 'low' | 'medium' | 'high' | 'critical';\nexport type NotificationStatus = 'unread' | 'read' | 'archived';\n\nexport interface Notification {\n  id: string;\n  userId: string;\n  type: NotificationType;\n  title: string;\n  message: string;\n  priority: NotificationPriority;\n  status: NotificationStatus;\n  actionUrl?: string;\n  actionLabel?: string;\n  metadata?: Record<string, any>;\n  createdAt: number;\n  readAt?: number;\n  expiresAt?: number;\n}\n\nexport interface NotificationPreference {\n  userId: string;\n  type: NotificationType;\n  enabled: boolean;\n  channels: ('in_app' | 'email' | 'sms' | 'push')[];\n  quietHours?: {\n    enabled: boolean;\n    startTime: string; // HH:mm\n    endTime: string; // HH:mm\n  };\n}\n\nexport interface NotificationChannel {\n  id: string;\n  userId: string;\n  type: 'websocket' | 'email' | 'sms' | 'push';\n  address: string; // email, phone, device token\n  isActive: boolean;\n  verifiedAt?: number;\n}\n\nexport interface NotificationStatistics {\n  totalNotifications: number;\n  unreadCount: number;\n  byType: Record<NotificationType, number>;\n  byPriority: Record<NotificationPriority, number>;\n  deliveryRate: number;\n  failureRate: number;\n}\n\nclass NotificationsSystem extends EventEmitter {\n  private notifications: Map<string, Notification> = new Map();\n  private preferences: Map<string, NotificationPreference[]> = new Map();\n  private channels: Map<string, NotificationChannel[]> = new Map();\n  private subscribers: Map<string, Set<(notification: Notification) => void>> = new Map();\n  private deliveryLog: Array<{ notificationId: string; channel: string; status: 'success' | 'failed'; timestamp: number }> = [];\n  private statistics: NotificationStatistics = {\n    totalNotifications: 0,\n    unreadCount: 0,\n    byType: {} as Record<NotificationType, number>,\n    byPriority: { low: 0, medium: 0, high: 0, critical: 0 },\n    deliveryRate: 100,\n    failureRate: 0,\n  };\n\n  constructor() {\n    super();\n    this.initializeDefaultPreferences();\n  }\n\n  /**\n   * Initialize default notification preferences\n   */\n  private initializeDefaultPreferences(): void {\n    const types: NotificationType[] = [\n      'audit_alert',\n      'export_complete',\n      'export_failed',\n      'sync_started',\n      'sync_completed',\n      'sync_failed',\n      'performance_warning',\n      'critical_error',\n      'template_shared',\n      'comment_added',\n      'permission_changed',\n      'system_maintenance',\n    ];\n\n    for (const type of types) {\n      this.statistics.byType[type] = 0;\n    }\n  }\n\n  /**\n   * Create and send notification\n   */\n  async sendNotification(\n    userId: string,\n    type: NotificationType,\n    title: string,\n    message: string,\n    options?: {\n      priority?: NotificationPriority;\n      actionUrl?: string;\n      actionLabel?: string;\n      metadata?: Record<string, any>;\n      expiresIn?: number; // milliseconds\n    }\n  ): Promise<Notification> {\n    const notification: Notification = {\n      id: `notif-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,\n      userId,\n      type,\n      title,\n      message,\n      priority: options?.priority || 'medium',\n      status: 'unread',\n      actionUrl: options?.actionUrl,\n      actionLabel: options?.actionLabel,\n      metadata: options?.metadata,\n      createdAt: Date.now(),\n      expiresAt: options?.expiresIn ? Date.now() + options.expiresIn : undefined,\n    };\n\n    this.notifications.set(notification.id, notification);\n    this.updateStatistics();\n\n    // Deliver notification\n    await this.deliverNotification(notification);\n\n    this.emit('notification:sent', notification);\n    return notification;\n  }\n\n  /**\n   * Deliver notification to user\n   */\n  private async deliverNotification(notification: Notification): Promise<void> {\n    const preferences = this.getPreferences(notification.userId);\n    const channels = this.getChannels(notification.userId);\n\n    // Find preferences for this notification type\n    const pref = preferences.find((p) => p.type === notification.type);\n\n    if (!pref || !pref.enabled) {\n      return;\n    }\n\n    // Check quiet hours\n    if (pref.quietHours?.enabled && this.isInQuietHours(pref.quietHours)) {\n      // Only deliver critical notifications during quiet hours\n      if (notification.priority !== 'critical') {\n        return;\n      }\n    }\n\n    // Deliver through enabled channels\n    for (const channelType of pref.channels) {\n      const channel = channels.find((c) => c.type === channelType && c.isActive);\n      if (channel) {\n        await this.deliverToChannel(notification, channel);\n      }\n    }\n  }\n\n  /**\n   * Deliver to specific channel\n   */\n  private async deliverToChannel(notification: Notification, channel: NotificationChannel): Promise<void> {\n    try {\n      switch (channel.type) {\n        case 'websocket':\n          this.deliverViaWebSocket(notification, channel);\n          break;\n        case 'email':\n          await this.deliverViaEmail(notification, channel);\n          break;\n        case 'sms':\n          await this.deliverViaSMS(notification, channel);\n          break;\n        case 'push':\n          await this.deliverViaPush(notification, channel);\n          break;\n      }\n\n      this.logDelivery(notification.id, channel.type, 'success');\n    } catch (error) {\n      this.logDelivery(notification.id, channel.type, 'failed');\n      this.emit('delivery:failed', { notificationId: notification.id, channel: channel.type, error });\n    }\n  }\n\n  /**\n   * Deliver via WebSocket (real-time)\n   */\n  private deliverViaWebSocket(notification: Notification, channel: NotificationChannel): void {\n    const subscribers = this.subscribers.get(notification.userId);\n    if (subscribers) {\n      for (const callback of subscribers) {\n        callback(notification);\n      }\n    }\n  }\n\n  /**\n   * Deliver via Email\n   */\n  private async deliverViaEmail(notification: Notification, channel: NotificationChannel): Promise<void> {\n    // Simulate email delivery\n    return new Promise((resolve) => {\n      setTimeout(() => {\n        this.emit('email:sent', { to: channel.address, notificationId: notification.id });\n        resolve();\n      }, 100);\n    });\n  }\n\n  /**\n   * Deliver via SMS\n   */\n  private async deliverViaSMS(notification: Notification, channel: NotificationChannel): Promise<void> {\n    // Simulate SMS delivery\n    return new Promise((resolve) => {\n      setTimeout(() => {\n        this.emit('sms:sent', { to: channel.address, notificationId: notification.id });\n        resolve();\n      }, 100);\n    });\n  }\n\n  /**\n   * Deliver via Push Notification\n   */\n  private async deliverViaPush(notification: Notification, channel: NotificationChannel): Promise<void> {\n    // Simulate push notification delivery\n    return new Promise((resolve) => {\n      setTimeout(() => {\n        this.emit('push:sent', { deviceToken: channel.address, notificationId: notification.id });\n        resolve();\n      }, 100);\n    });\n  }\n\n  /**\n   * Log delivery attempt\n   */\n  private logDelivery(notificationId: string, channel: string, status: 'success' | 'failed'): void {\n    this.deliveryLog.push({\n      notificationId,\n      channel,\n      status,\n      timestamp: Date.now(),\n    });\n\n    // Keep only last 10000 logs\n    if (this.deliveryLog.length > 10000) {\n      this.deliveryLog = this.deliveryLog.slice(-10000);\n    }\n  }\n\n  /**\n   * Check if current time is in quiet hours\n   */\n  private isInQuietHours(quietHours: { startTime: string; endTime: string }): boolean {\n    const now = new Date();\n    const currentTime = `${String(now.getHours()).padStart(2, '0')}:${String(now.getMinutes()).padStart(2, '0')}`;\n\n    const [startHour, startMin] = quietHours.startTime.split(':').map(Number);\n    const [endHour, endMin] = quietHours.endTime.split(':').map(Number);\n    const [currentHour, currentMin] = currentTime.split(':').map(Number);\n\n    const startTotalMin = startHour * 60 + startMin;\n    const endTotalMin = endHour * 60 + endMin;\n    const currentTotalMin = currentHour * 60 + currentMin;\n\n    if (startTotalMin <= endTotalMin) {\n      return currentTotalMin >= startTotalMin && currentTotalMin <= endTotalMin;\n    } else {\n      return currentTotalMin >= startTotalMin || currentTotalMin <= endTotalMin;\n    }\n  }\n\n  /**\n   * Subscribe to notifications\n   */\n  subscribe(userId: string, callback: (notification: Notification) => void): () => void {\n    if (!this.subscribers.has(userId)) {\n      this.subscribers.set(userId, new Set());\n    }\n\n    this.subscribers.get(userId)!.add(callback);\n\n    // Return unsubscribe function\n    return () => {\n      this.subscribers.get(userId)?.delete(callback);\n    };\n  }\n\n  /**\n   * Get notifications for user\n   */\n  getNotifications(userId: string, status?: NotificationStatus, limit: number = 100): Notification[] {\n    const userNotifs = Array.from(this.notifications.values()).filter((n) => n.userId === userId);\n\n    if (status) {\n      return userNotifs.filter((n) => n.status === status).slice(-limit);\n    }\n\n    return userNotifs.slice(-limit);\n  }\n\n  /**\n   * Mark notification as read\n   */\n  markAsRead(notificationId: string): boolean {\n    const notif = this.notifications.get(notificationId);\n    if (notif) {\n      notif.status = 'read';\n      notif.readAt = Date.now();\n      this.updateStatistics();\n      this.emit('notification:read', notif);\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Mark all notifications as read\n   */\n  markAllAsRead(userId: string): number {\n    let count = 0;\n    for (const notif of this.notifications.values()) {\n      if (notif.userId === userId && notif.status === 'unread') {\n        notif.status = 'read';\n        notif.readAt = Date.now();\n        count++;\n      }\n    }\n    this.updateStatistics();\n    return count;\n  }\n\n  /**\n   * Archive notification\n   */\n  archiveNotification(notificationId: string): boolean {\n    const notif = this.notifications.get(notificationId);\n    if (notif) {\n      notif.status = 'archived';\n      this.updateStatistics();\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Delete notification\n   */\n  deleteNotification(notificationId: string): boolean {\n    return this.notifications.delete(notificationId);\n  }\n\n  /**\n   * Set notification preference\n   */\n  setPreference(userId: string, type: NotificationType, preference: Partial<NotificationPreference>): void {\n    if (!this.preferences.has(userId)) {\n      this.preferences.set(userId, []);\n    }\n\n    const prefs = this.preferences.get(userId)!;\n    const existing = prefs.find((p) => p.type === type);\n\n    if (existing) {\n      Object.assign(existing, preference);\n    } else {\n      prefs.push({\n        userId,\n        type,\n        enabled: true,\n        channels: ['in_app'],\n        ...preference,\n      });\n    }\n\n    this.emit('preference:updated', { userId, type });\n  }\n\n  /**\n   * Get preferences\n   */\n  getPreferences(userId: string): NotificationPreference[] {\n    if (!this.preferences.has(userId)) {\n      // Create default preferences\n      const defaultPrefs: NotificationPreference[] = [\n        { userId, type: 'critical_error', enabled: true, channels: ['in_app', 'email'] },\n        { userId, type: 'export_complete', enabled: true, channels: ['in_app'] },\n        { userId, type: 'sync_completed', enabled: true, channels: ['in_app'] },\n        { userId, type: 'audit_alert', enabled: true, channels: ['in_app'] },\n      ];\n      this.preferences.set(userId, defaultPrefs);\n    }\n\n    return this.preferences.get(userId)!;\n  }\n\n  /**\n   * Add notification channel\n   */\n  addChannel(userId: string, channel: Omit<NotificationChannel, 'id'>): NotificationChannel {\n    if (!this.channels.has(userId)) {\n      this.channels.set(userId, []);\n    }\n\n    const newChannel: NotificationChannel = {\n      id: `channel-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,\n      ...channel,\n    };\n\n    this.channels.get(userId)!.push(newChannel);\n    this.emit('channel:added', newChannel);\n\n    return newChannel;\n  }\n\n  /**\n   * Get channels\n   */\n  getChannels(userId: string): NotificationChannel[] {\n    return this.channels.get(userId) || [];\n  }\n\n  /**\n   * Remove channel\n   */\n  removeChannel(userId: string, channelId: string): boolean {\n    const userChannels = this.channels.get(userId);\n    if (userChannels) {\n      const index = userChannels.findIndex((c) => c.id === channelId);\n      if (index >= 0) {\n        userChannels.splice(index, 1);\n        this.emit('channel:removed', { userId, channelId });\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Update statistics\n   */\n  private updateStatistics(): void {\n    this.statistics.totalNotifications = this.notifications.size;\n    this.statistics.unreadCount = Array.from(this.notifications.values()).filter(\n      (n) => n.status === 'unread'\n    ).length;\n\n    // Count by type\n    for (const type of Object.keys(this.statistics.byType)) {\n      this.statistics.byType[type as NotificationType] = Array.from(this.notifications.values()).filter(\n        (n) => n.type === type\n      ).length;\n    }\n\n    // Count by priority\n    this.statistics.byPriority = { low: 0, medium: 0, high: 0, critical: 0 };\n    for (const notif of this.notifications.values()) {\n      this.statistics.byPriority[notif.priority]++;\n    }\n\n    // Calculate delivery rates\n    if (this.deliveryLog.length > 0) {\n      const successCount = this.deliveryLog.filter((l) => l.status === 'success').length;\n      this.statistics.deliveryRate = (successCount / this.deliveryLog.length) * 100;\n      this.statistics.failureRate = 100 - this.statistics.deliveryRate;\n    }\n  }\n\n  /**\n   * Get statistics\n   */\n  getStatistics(): NotificationStatistics {\n    this.updateStatistics();\n    return { ...this.statistics };\n  }\n\n  /**\n   * Get unread count for user\n   */\n  getUnreadCount(userId: string): number {\n    return Array.from(this.notifications.values()).filter(\n      (n) => n.userId === userId && n.status === 'unread'\n    ).length;\n  }\n\n  /**\n   * Clean expired notifications\n   */\n  cleanExpiredNotifications(): number {\n    const now = Date.now();\n    let removed = 0;\n\n    for (const [id, notif] of this.notifications.entries()) {\n      if (notif.expiresAt && notif.expiresAt < now) {\n        this.notifications.delete(id);\n        removed++;\n      }\n    }\n\n    this.updateStatistics();\n    return removed;\n  }\n\n  /**\n   * Bulk send notifications\n   */\n  async bulkSend(\n    userIds: string[],\n    type: NotificationType,\n    title: string,\n    message: string,\n    options?: any\n  ): Promise<Notification[]> {\n    const notifications: Notification[] = [];\n\n    for (const userId of userIds) {\n      const notif = await this.sendNotification(userId, type, title, message, options);\n      notifications.push(notif);\n    }\n\n    this.emit('bulk:sent', { count: notifications.length, type });\n    return notifications;\n  }\n\n  /**\n   * Get delivery history\n   */\n  getDeliveryHistory(notificationId?: string, limit: number = 100): typeof this.deliveryLog {\n    if (notificationId) {\n      return this.deliveryLog.filter((l) => l.notificationId === notificationId).slice(-limit);\n    }\n    return this.deliveryLog.slice(-limit);\n  }\n}\n\nexport default NotificationsSystem;\n
