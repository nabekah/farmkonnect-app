import { EventEmitter } from 'events';\n\nexport interface ConsolidatedMetrics {\n  farmId: string;\n  period: { start: number; end: number };\n  totalRevenue: number;\n  equipmentCosts: number;\n  laborCosts: number;\n  inventoryCosts: number;\n  fuelCosts: number;\n  totalExpenses: number;\n  grossProfit: number;\n  netProfit: number;\n  profitMargin: number;\n  roi: number;\n}\n\nexport interface CostBreakdown {\n  equipment: number;\n  labor: number;\n  inventory: number;\n  fuel: number;\n  seeds: number;\n  fertilizer: number;\n  pesticides: number;\n  other: number;\n  total: number;\n}\n\nexport interface RevenueSource {\n  source: string;\n  amount: number;\n  percentage: number;\n}\n\nexport interface KPI {\n  name: string;\n  value: number;\n  unit: string;\n  trend: 'up' | 'down' | 'stable';\n  trendPercentage: number;\n}\n\nexport interface FinancialSnapshot {\n  id: string;\n  farmId: string;\n  date: number;\n  metrics: ConsolidatedMetrics;\n  costBreakdown: CostBreakdown;\n  revenueSources: RevenueSource[];\n  kpis: KPI[];\n  alerts: string[];\n  recommendations: string[];\n}\n\nexport interface FinancialTrend {\n  period: string;\n  revenue: number;\n  expenses: number;\n  profit: number;\n  profitMargin: number;\n}\n\n/**\n * Financial Consolidation Dashboard\n */\nexport class FinancialConsolidationDashboard extends EventEmitter {\n  private snapshots: Map<string, FinancialSnapshot> = new Map();\n  private trends: Map<string, FinancialTrend[]> = new Map();\n\n  constructor() {\n    super();\n  }\n\n  /**\n   * Create consolidated metrics\n   */\n  createConsolidatedMetrics(\n    farmId: string,\n    totalRevenue: number,\n    equipmentCosts: number,\n    laborCosts: number,\n    inventoryCosts: number,\n    fuelCosts: number,\n    otherCosts: number,\n    startDate: number,\n    endDate: number\n  ): ConsolidatedMetrics {\n    const totalExpenses = equipmentCosts + laborCosts + inventoryCosts + fuelCosts + otherCosts;\n    const grossProfit = totalRevenue;\n    const netProfit = totalRevenue - totalExpenses;\n    const profitMargin = totalRevenue > 0 ? (netProfit / totalRevenue) * 100 : 0;\n    const roi = totalExpenses > 0 ? (netProfit / totalExpenses) * 100 : 0;\n\n    return {\n      farmId,\n      period: { start: startDate, end: endDate },\n      totalRevenue,\n      equipmentCosts,\n      laborCosts,\n      inventoryCosts,\n      fuelCosts,\n      totalExpenses,\n      grossProfit,\n      netProfit,\n      profitMargin,\n      roi,\n    };\n  }\n\n  /**\n   * Create cost breakdown\n   */\n  createCostBreakdown(\n    equipment: number,\n    labor: number,\n    inventory: number,\n    fuel: number,\n    seeds: number,\n    fertilizer: number,\n    pesticides: number,\n    other: number\n  ): CostBreakdown {\n    const total = equipment + labor + inventory + fuel + seeds + fertilizer + pesticides + other;\n\n    return {\n      equipment,\n      labor,\n      inventory,\n      fuel,\n      seeds,\n      fertilizer,\n      pesticides,\n      other,\n      total,\n    };\n  }\n\n  /**\n   * Calculate revenue sources\n   */\n  calculateRevenueSources(\n    wheat: number,\n    corn: number,\n    soybean: number,\n    rice: number,\n    barley: number,\n    other: number\n  ): RevenueSource[] {\n    const total = wheat + corn + soybean + rice + barley + other;\n    const sources: RevenueSource[] = [];\n\n    if (wheat > 0) sources.push({ source: 'Wheat', amount: wheat, percentage: (wheat / total) * 100 });\n    if (corn > 0) sources.push({ source: 'Corn', amount: corn, percentage: (corn / total) * 100 });\n    if (soybean > 0) sources.push({ source: 'Soybean', amount: soybean, percentage: (soybean / total) * 100 });\n    if (rice > 0) sources.push({ source: 'Rice', amount: rice, percentage: (rice / total) * 100 });\n    if (barley > 0) sources.push({ source: 'Barley', amount: barley, percentage: (barley / total) * 100 });\n    if (other > 0) sources.push({ source: 'Other', amount: other, percentage: (other / total) * 100 });\n\n    return sources.sort((a, b) => b.amount - a.amount);\n  }\n\n  /**\n   * Generate KPIs\n   */\n  generateKPIs(metrics: ConsolidatedMetrics, previousMetrics?: ConsolidatedMetrics): KPI[] {\n    const kpis: KPI[] = [];\n\n    // Profit Margin KPI\n    let profitMarginTrend: 'up' | 'down' | 'stable' = 'stable';\n    let profitMarginTrendPercent = 0;\n    if (previousMetrics) {\n      profitMarginTrendPercent = metrics.profitMargin - previousMetrics.profitMargin;\n      profitMarginTrend = profitMarginTrendPercent > 0 ? 'up' : profitMarginTrendPercent < 0 ? 'down' : 'stable';\n    }\n    kpis.push({\n      name: 'Profit Margin',\n      value: metrics.profitMargin,\n      unit: '%',\n      trend: profitMarginTrend,\n      trendPercentage: profitMarginTrendPercent,\n    });\n\n    // ROI KPI\n    let roiTrend: 'up' | 'down' | 'stable' = 'stable';\n    let roiTrendPercent = 0;\n    if (previousMetrics) {\n      roiTrendPercent = metrics.roi - previousMetrics.roi;\n      roiTrend = roiTrendPercent > 0 ? 'up' : roiTrendPercent < 0 ? 'down' : 'stable';\n    }\n    kpis.push({\n      name: 'ROI',\n      value: metrics.roi,\n      unit: '%',\n      trend: roiTrend,\n      trendPercentage: roiTrendPercent,\n    });\n\n    // Revenue KPI\n    let revenueTrend: 'up' | 'down' | 'stable' = 'stable';\n    let revenueTrendPercent = 0;\n    if (previousMetrics) {\n      revenueTrendPercent = ((metrics.totalRevenue - previousMetrics.totalRevenue) / previousMetrics.totalRevenue) * 100;\n      revenueTrend = revenueTrendPercent > 0 ? 'up' : revenueTrendPercent < 0 ? 'down' : 'stable';\n    }\n    kpis.push({\n      name: 'Total Revenue',\n      value: metrics.totalRevenue,\n      unit: '$',\n      trend: revenueTrend,\n      trendPercentage: revenueTrendPercent,\n    });\n\n    // Net Profit KPI\n    let profitTrend: 'up' | 'down' | 'stable' = 'stable';\n    let profitTrendPercent = 0;\n    if (previousMetrics) {\n      profitTrendPercent = ((metrics.netProfit - previousMetrics.netProfit) / Math.abs(previousMetrics.netProfit)) * 100;\n      profitTrend = profitTrendPercent > 0 ? 'up' : profitTrendPercent < 0 ? 'down' : 'stable';\n    }\n    kpis.push({\n      name: 'Net Profit',\n      value: metrics.netProfit,\n      unit: '$',\n      trend: profitTrend,\n      trendPercentage: profitTrendPercent,\n    });\n\n    return kpis;\n  }\n\n  /**\n   * Create financial snapshot\n   */\n  createFinancialSnapshot(\n    farmId: string,\n    metrics: ConsolidatedMetrics,\n    costBreakdown: CostBreakdown,\n    revenueSources: RevenueSource[],\n    kpis: KPI[]\n  ): FinancialSnapshot {\n    const snapshotId = `snapshot_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n    const alerts: string[] = [];\n    const recommendations: string[] = [];\n\n    // Generate alerts\n    if (metrics.profitMargin < 0) {\n      alerts.push('Negative profit margin - expenses exceed revenue');\n      recommendations.push('Review cost structure and identify areas for reduction');\n    } else if (metrics.profitMargin < 10) {\n      alerts.push('Low profit margin - below industry standard');\n      recommendations.push('Optimize operations to improve profitability');\n    }\n\n    if (costBreakdown.labor > metrics.totalRevenue * 0.4) {\n      alerts.push('Labor costs exceed 40% of revenue');\n      recommendations.push('Review labor allocation and productivity');\n    }\n\n    if (costBreakdown.equipment > metrics.totalRevenue * 0.2) {\n      alerts.push('Equipment costs exceed 20% of revenue');\n      recommendations.push('Evaluate equipment efficiency and maintenance');\n    }\n\n    const snapshot: FinancialSnapshot = {\n      id: snapshotId,\n      farmId,\n      date: Date.now(),\n      metrics,\n      costBreakdown,\n      revenueSources,\n      kpis,\n      alerts,\n      recommendations,\n    };\n\n    this.snapshots.set(snapshotId, snapshot);\n    this.emit('snapshot:created', { snapshotId, farmId, profitMargin: metrics.profitMargin });\n    return snapshot;\n  }\n\n  /**\n   * Get financial snapshot\n   */\n  getFinancialSnapshot(snapshotId: string): FinancialSnapshot | null {\n    return this.snapshots.get(snapshotId) || null;\n  }\n\n  /**\n   * Get latest snapshot\n   */\n  getLatestSnapshot(farmId: string): FinancialSnapshot | null {\n    const farmSnapshots = Array.from(this.snapshots.values())\n      .filter((s) => s.farmId === farmId)\n      .sort((a, b) => b.date - a.date);\n\n    return farmSnapshots.length > 0 ? farmSnapshots[0] : null;\n  }\n\n  /**\n   * Record financial trend\n   */\n  recordFinancialTrend(\n    farmId: string,\n    period: string,\n    revenue: number,\n    expenses: number,\n    profit: number\n  ): FinancialTrend {\n    const profitMargin = revenue > 0 ? (profit / revenue) * 100 : 0;\n    const trend: FinancialTrend = {\n      period,\n      revenue,\n      expenses,\n      profit,\n      profitMargin,\n    };\n\n    if (!this.trends.has(farmId)) {\n      this.trends.set(farmId, []);\n    }\n\n    this.trends.get(farmId)!.push(trend);\n    this.emit('trend:recorded', { farmId, period, profit });\n    return trend;\n  }\n\n  /**\n   * Get financial trends\n   */\n  getFinancialTrends(farmId: string): FinancialTrend[] {\n    return this.trends.get(farmId) || [];\n  }\n\n  /**\n   * Compare periods\n   */\n  comparePeriods(\n    farmId: string,\n    period1: string,\n    period2: string\n  ): { period1: FinancialTrend | null; period2: FinancialTrend | null; comparison: Record<string, number> } {\n    const trends = this.getFinancialTrends(farmId);\n    const p1 = trends.find((t) => t.period === period1) || null;\n    const p2 = trends.find((t) => t.period === period2) || null;\n\n    const comparison: Record<string, number> = {};\n    if (p1 && p2) {\n      comparison.revenueChange = ((p2.revenue - p1.revenue) / p1.revenue) * 100;\n      comparison.expenseChange = ((p2.expenses - p1.expenses) / p1.expenses) * 100;\n      comparison.profitChange = ((p2.profit - p1.profit) / Math.abs(p1.profit)) * 100;\n      comparison.marginChange = p2.profitMargin - p1.profitMargin;\n    }\n\n    return { period1: p1, period2: p2, comparison };\n  }\n\n  /**\n   * Get statistics\n   */\n  getStatistics(): {\n    totalSnapshots: number;\n    totalTrends: number;\n  } {\n    return {\n      totalSnapshots: this.snapshots.size,\n      totalTrends: Array.from(this.trends.values()).reduce((sum, trends) => sum + trends.length, 0),\n    };\n  }\n}\n
