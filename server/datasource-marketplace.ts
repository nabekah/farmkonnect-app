import { EventEmitter } from 'events';\nimport { v4 as uuidv4 } from 'uuid';\n\nexport interface MarketplaceSource {\n  id: string;\n  name: string;\n  description: string;\n  category: 'weather' | 'market' | 'soil' | 'equipment' | 'analytics' | 'custom';\n  type: 'api' | 'database' | 'cache' | 'computed' | 'webhook';\n  icon?: string;\n  rating: number; // 0-5\n  downloads: number;\n  author: string;\n  version: string;\n  config: Record<string, any>;\n  documentation?: string;\n  tags?: string[];\n  isPremium: boolean;\n  isVerified: boolean;\n  createdAt: number;\n  updatedAt: number;\n}\n\nexport interface MarketplaceReview {\n  id: string;\n  sourceId: string;\n  userId: string;\n  rating: number;\n  comment: string;\n  createdAt: number;\n}\n\nexport interface MarketplaceInstallation {\n  id: string;\n  sourceId: string;\n  userId: string;\n  farmId: string;\n  customConfig?: Record<string, any>;\n  installedAt: number;\n  isActive: boolean;\n}\n\nexport class DataSourceMarketplace extends EventEmitter {\n  private sources: Map<string, MarketplaceSource> = new Map();\n  private reviews: Map<string, MarketplaceReview[]> = new Map();\n  private installations: Map<string, MarketplaceInstallation[]> = new Map();\n  private favorites: Map<string, Set<string>> = new Map(); // userId -> Set<sourceId>\n\n  constructor() {\n    super();\n    this.initializeDefaultSources();\n  }\n\n  /**\n   * Initialize marketplace with default sources\n   */\n  private initializeDefaultSources(): void {\n    // Weather API\n    this.addSource({\n      id: 'weather-openweather',\n      name: 'OpenWeather API',\n      description: 'Real-time weather data and forecasting for farm locations',\n      category: 'weather',\n      type: 'api',\n      rating: 4.8,\n      downloads: 1250,\n      author: 'OpenWeather',\n      version: '3.0',\n      config: {\n        url: 'https://api.openweathermap.org/data/2.5/weather',\n        method: 'GET',\n        timeout: 5000,\n        requiredParams: ['lat', 'lon', 'appid'],\n      },\n      documentation: 'https://openweathermap.org/api',\n      tags: ['weather', 'real-time', 'forecasting'],\n      isPremium: false,\n      isVerified: true,\n      createdAt: Date.now() - 86400000 * 30,\n      updatedAt: Date.now(),\n    });\n\n    // Market Prices\n    this.addSource({\n      id: 'market-usda',\n      name: 'USDA Market Prices',\n      description: 'Agricultural commodity prices from USDA QuickStats',\n      category: 'market',\n      type: 'api',\n      rating: 4.6,\n      downloads: 890,\n      author: 'USDA',\n      version: '2.0',\n      config: {\n        url: 'https://quickstats.nass.usda.gov/api',\n        method: 'GET',\n        timeout: 10000,\n        requiredParams: ['key', 'commodity'],\n      },\n      documentation: 'https://quickstats.nass.usda.gov/api',\n      tags: ['market', 'prices', 'commodities'],\n      isPremium: false,\n      isVerified: true,\n      createdAt: Date.now() - 86400000 * 45,\n      updatedAt: Date.now(),\n    });\n\n    // Soil Health\n    this.addSource({\n      id: 'soil-nrcs',\n      name: 'NRCS Soil Data',\n      description: 'Soil composition and health data from NRCS database',\n      category: 'soil',\n      type: 'api',\n      rating: 4.5,\n      downloads: 620,\n      author: 'NRCS',\n      version: '1.5',\n      config: {\n        url: 'https://sdmdataaccess.nrcs.usda.gov/Tabular/SDMTabularService/post',\n        method: 'POST',\n        timeout: 15000,\n        requiredParams: ['areaSymbol'],\n      },\n      documentation: 'https://nrcs.usda.gov/wps/portal/nrcs/detail/soils',\n      tags: ['soil', 'health', 'composition'],\n      isPremium: false,\n      isVerified: true,\n      createdAt: Date.now() - 86400000 * 60,\n      updatedAt: Date.now(),\n    });\n\n    // Equipment Tracking\n    this.addSource({\n      id: 'equipment-gps',\n      name: 'GPS Equipment Tracker',\n      description: 'Real-time GPS tracking for farm equipment and machinery',\n      category: 'equipment',\n      type: 'api',\n      rating: 4.7,\n      downloads: 1100,\n      author: 'FarmKonnect',\n      version: '2.1',\n      config: {\n        url: 'https://api.farmkonnect.com/equipment/location',\n        method: 'GET',\n        timeout: 5000,\n        requiredParams: ['equipmentId'],\n      },\n      documentation: 'https://docs.farmkonnect.com/equipment',\n      tags: ['equipment', 'gps', 'tracking'],\n      isPremium: true,\n      isVerified: true,\n      createdAt: Date.now() - 86400000 * 15,\n      updatedAt: Date.now(),\n    });\n\n    // Analytics Engine\n    this.addSource({\n      id: 'analytics-yield',\n      name: 'Yield Analytics Engine',\n      description: 'ML-powered yield prediction and farm analytics',\n      category: 'analytics',\n      type: 'computed',\n      rating: 4.9,\n      downloads: 1450,\n      author: 'FarmKonnect',\n      version: '3.2',\n      config: {\n        script: 'predictYield',\n        inputs: ['soilHealth', 'weather', 'cropHistory'],\n        outputs: ['yieldForecast', 'confidence'],\n      },\n      documentation: 'https://docs.farmkonnect.com/analytics',\n      tags: ['analytics', 'yield', 'prediction', 'ml'],\n      isPremium: true,\n      isVerified: true,\n      createdAt: Date.now() - 86400000 * 20,\n      updatedAt: Date.now(),\n    });\n\n    // Pest Detection\n    this.addSource({\n      id: 'pest-detection',\n      name: 'Pest Detection AI',\n      description: 'AI-powered pest and disease identification from images',\n      category: 'analytics',\n      type: 'api',\n      rating: 4.4,\n      downloads: 780,\n      author: 'AgriTech AI',\n      version: '1.8',\n      config: {\n        url: 'https://api.agritech.ai/pest-detection',\n        method: 'POST',\n        timeout: 30000,\n        requiredParams: ['image'],\n      },\n      documentation: 'https://docs.agritech.ai/pest-detection',\n      tags: ['pest', 'disease', 'ai', 'detection'],\n      isPremium: true,\n      isVerified: true,\n      createdAt: Date.now() - 86400000 * 10,\n      updatedAt: Date.now(),\n    });\n\n    // Irrigation Optimization\n    this.addSource({\n      id: 'irrigation-optimizer',\n      name: 'Irrigation Optimizer',\n      description: 'Smart irrigation scheduling based on weather and soil moisture',\n      category: 'analytics',\n      type: 'computed',\n      rating: 4.6,\n      downloads: 950,\n      author: 'FarmKonnect',\n      version: '2.3',\n      config: {\n        script: 'optimizeIrrigation',\n        inputs: ['soilMoisture', 'weather', 'cropType'],\n        outputs: ['irrigationSchedule', 'waterSavings'],\n      },\n      documentation: 'https://docs.farmkonnect.com/irrigation',\n      tags: ['irrigation', 'optimization', 'water'],\n      isPremium: true,\n      isVerified: true,\n      createdAt: Date.now() - 86400000 * 25,\n      updatedAt: Date.now(),\n    });\n  }\n\n  /**\n   * Add source to marketplace\n   */\n  addSource(source: Omit<MarketplaceSource, 'id'> & { id?: string }): MarketplaceSource {\n    const id = source.id || uuidv4();\n    const fullSource: MarketplaceSource = {\n      ...source,\n      id,\n    } as MarketplaceSource;\n\n    this.sources.set(id, fullSource);\n    this.emit('source:added', fullSource);\n    return fullSource;\n  }\n\n  /**\n   * Get source by ID\n   */\n  getSource(sourceId: string): MarketplaceSource | null {\n    return this.sources.get(sourceId) || null;\n  }\n\n  /**\n   * Search sources\n   */\n  searchSources(\n    query: string,\n    category?: string,\n    limit: number = 20\n  ): MarketplaceSource[] {\n    let results = Array.from(this.sources.values());\n\n    // Filter by category\n    if (category) {\n      results = results.filter((s) => s.category === category);\n    }\n\n    // Filter by query\n    if (query) {\n      const lowerQuery = query.toLowerCase();\n      results = results.filter(\n        (s) =>\n          s.name.toLowerCase().includes(lowerQuery) ||\n          s.description.toLowerCase().includes(lowerQuery) ||\n          s.tags?.some((t) => t.toLowerCase().includes(lowerQuery))\n      );\n    }\n\n    // Sort by rating and downloads\n    results.sort((a, b) => {\n      const ratingDiff = b.rating - a.rating;\n      if (ratingDiff !== 0) return ratingDiff;\n      return b.downloads - a.downloads;\n    });\n\n    return results.slice(0, limit);\n  }\n\n  /**\n   * Get sources by category\n   */\n  getSourcesByCategory(\n    category: string,\n    limit: number = 20\n  ): MarketplaceSource[] {\n    return this.searchSources('', category, limit);\n  }\n\n  /**\n   * Get trending sources\n   */\n  getTrendingSources(limit: number = 10): MarketplaceSource[] {\n    return Array.from(this.sources.values())\n      .sort((a, b) => b.downloads - a.downloads)\n      .slice(0, limit);\n  }\n\n  /**\n   * Get top rated sources\n   */\n  getTopRatedSources(limit: number = 10): MarketplaceSource[] {\n    return Array.from(this.sources.values())\n      .sort((a, b) => b.rating - a.rating)\n      .slice(0, limit);\n  }\n\n  /**\n   * Install source for user\n   */\n  installSource(\n    sourceId: string,\n    userId: string,\n    farmId: string,\n    customConfig?: Record<string, any>\n  ): MarketplaceInstallation | null {\n    const source = this.getSource(sourceId);\n    if (!source) return null;\n\n    const installation: MarketplaceInstallation = {\n      id: uuidv4(),\n      sourceId,\n      userId,\n      farmId,\n      customConfig,\n      installedAt: Date.now(),\n      isActive: true,\n    };\n\n    if (!this.installations.has(userId)) {\n      this.installations.set(userId, []);\n    }\n\n    this.installations.get(userId)!.push(installation);\n\n    // Increment download count\n    source.downloads++;\n    source.updatedAt = Date.now();\n\n    this.emit('source:installed', installation);\n    return installation;\n  }\n\n  /**\n   * Uninstall source\n   */\n  uninstallSource(installationId: string, userId: string): boolean {\n    const installations = this.installations.get(userId);\n    if (!installations) return false;\n\n    const index = installations.findIndex((i) => i.id === installationId);\n    if (index === -1) return false;\n\n    installations.splice(index, 1);\n    this.emit('source:uninstalled', { installationId, userId });\n    return true;\n  }\n\n  /**\n   * Get user installations\n   */\n  getUserInstallations(userId: string): MarketplaceInstallation[] {\n    return this.installations.get(userId) || [];\n  }\n\n  /**\n   * Add review\n   */\n  addReview(\n    sourceId: string,\n    userId: string,\n    rating: number,\n    comment: string\n  ): MarketplaceReview | null {\n    const source = this.getSource(sourceId);\n    if (!source || rating < 1 || rating > 5) return null;\n\n    const review: MarketplaceReview = {\n      id: uuidv4(),\n      sourceId,\n      userId,\n      rating,\n      comment,\n      createdAt: Date.now(),\n    };\n\n    if (!this.reviews.has(sourceId)) {\n      this.reviews.set(sourceId, []);\n    }\n\n    this.reviews.get(sourceId)!.push(review);\n\n    // Update source rating\n    const allReviews = this.reviews.get(sourceId)!;\n    const avgRating = allReviews.reduce((sum, r) => sum + r.rating, 0) / allReviews.length;\n    source.rating = parseFloat(avgRating.toFixed(1));\n    source.updatedAt = Date.now();\n\n    this.emit('review:added', review);\n    return review;\n  }\n\n  /**\n   * Get reviews for source\n   */\n  getReviews(sourceId: string): MarketplaceReview[] {\n    return this.reviews.get(sourceId) || [];\n  }\n\n  /**\n   * Add to favorites\n   */\n  addToFavorites(userId: string, sourceId: string): boolean {\n    if (!this.getSource(sourceId)) return false;\n\n    if (!this.favorites.has(userId)) {\n      this.favorites.set(userId, new Set());\n    }\n\n    this.favorites.get(userId)!.add(sourceId);\n    this.emit('favorite:added', { userId, sourceId });\n    return true;\n  }\n\n  /**\n   * Remove from favorites\n   */\n  removeFromFavorites(userId: string, sourceId: string): boolean {\n    const favorites = this.favorites.get(userId);\n    if (!favorites) return false;\n\n    const removed = favorites.delete(sourceId);\n    if (removed) {\n      this.emit('favorite:removed', { userId, sourceId });\n    }\n    return removed;\n  }\n\n  /**\n   * Get user favorites\n   */\n  getFavorites(userId: string): MarketplaceSource[] {\n    const favorites = this.favorites.get(userId) || new Set();\n    return Array.from(favorites)\n      .map((id) => this.getSource(id))\n      .filter((s) => s !== null) as MarketplaceSource[];\n  }\n\n  /**\n   * Get marketplace statistics\n   */\n  getStatistics(): {\n    totalSources: number;\n    verifiedSources: number;\n    premiumSources: number;\n    totalDownloads: number;\n    averageRating: number;\n    categories: Record<string, number>;\n  } {\n    const sources = Array.from(this.sources.values());\n    const categories: Record<string, number> = {};\n\n    sources.forEach((s) => {\n      categories[s.category] = (categories[s.category] || 0) + 1;\n    });\n\n    return {\n      totalSources: sources.length,\n      verifiedSources: sources.filter((s) => s.isVerified).length,\n      premiumSources: sources.filter((s) => s.isPremium).length,\n      totalDownloads: sources.reduce((sum, s) => sum + s.downloads, 0),\n      averageRating: sources.reduce((sum, s) => sum + s.rating, 0) / sources.length,\n      categories,\n    };\n  }\n}\n\nexport default DataSourceMarketplace;\n
