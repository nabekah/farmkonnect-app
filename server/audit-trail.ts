import { EventEmitter } from 'events';\n\nexport type AuditAction =\n  | 'create'\n  | 'update'\n  | 'delete'\n  | 'export'\n  | 'sync'\n  | 'template_edit'\n  | 'filter_apply'\n  | 'login'\n  | 'logout'\n  | 'permission_change'\n  | 'settings_change';\n\nexport type AuditSeverity = 'info' | 'warning' | 'critical';\n\nexport interface AuditLog {\n  id: string;\n  userId: string;\n  username: string;\n  action: AuditAction;\n  resourceType: string;\n  resourceId: string;\n  resourceName?: string;\n  changes?: {\n    field: string;\n    oldValue: any;\n    newValue: any;\n  }[];\n  severity: AuditSeverity;\n  status: 'success' | 'failure';\n  errorMessage?: string;\n  ipAddress?: string;\n  userAgent?: string;\n  metadata?: Record<string, any>;\n  timestamp: number;\n  duration?: number; // in milliseconds\n}\n\nexport interface AuditFilter {\n  userId?: string;\n  action?: AuditAction;\n  resourceType?: string;\n  severity?: AuditSeverity;\n  status?: 'success' | 'failure';\n  startDate?: number;\n  endDate?: number;\n  searchQuery?: string;\n}\n\nexport interface AuditStatistics {\n  totalLogs: number;\n  logsByAction: Record<AuditAction, number>;\n  logsBySeverity: Record<AuditSeverity, number>;\n  logsByUser: Record<string, number>;\n  successRate: number;\n  averageActionDuration: number;\n  criticalActionsCount: number;\n}\n\nexport interface AuditReport {\n  id: string;\n  name: string;\n  description: string;\n  filters: AuditFilter;\n  format: 'pdf' | 'csv' | 'json';\n  generatedAt: number;\n  generatedBy: string;\n  logs: AuditLog[];\n  statistics: AuditStatistics;\n}\n\nclass AuditTrailManager extends EventEmitter {\n  private logs: AuditLog[] = [];\n  private maxLogs: number = 100000;\n  private statistics: AuditStatistics = {\n    totalLogs: 0,\n    logsByAction: {} as Record<AuditAction, number>,\n    logsBySeverity: { info: 0, warning: 0, critical: 0 },\n    logsByUser: {},\n    successRate: 100,\n    averageActionDuration: 0,\n    criticalActionsCount: 0,\n  };\n  private reports: Map<string, AuditReport> = new Map();\n  private searchIndex: Map<string, Set<string>> = new Map();\n\n  constructor() {\n    super();\n    this.initializeStatistics();\n  }\n\n  /**\n   * Initialize statistics\n   */\n  private initializeStatistics(): void {\n    const actions: AuditAction[] = [\n      'create',\n      'update',\n      'delete',\n      'export',\n      'sync',\n      'template_edit',\n      'filter_apply',\n      'login',\n      'logout',\n      'permission_change',\n      'settings_change',\n    ];\n\n    for (const action of actions) {\n      this.statistics.logsByAction[action] = 0;\n    }\n  }\n\n  /**\n   * Log an action\n   */\n  logAction(\n    userId: string,\n    username: string,\n    action: AuditAction,\n    resourceType: string,\n    resourceId: string,\n    options?: {\n      resourceName?: string;\n      changes?: AuditLog['changes'];\n      severity?: AuditSeverity;\n      status?: 'success' | 'failure';\n      errorMessage?: string;\n      ipAddress?: string;\n      userAgent?: string;\n      metadata?: Record<string, any>;\n      duration?: number;\n    }\n  ): AuditLog {\n    const log: AuditLog = {\n      id: `audit-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,\n      userId,\n      username,\n      action,\n      resourceType,\n      resourceId,\n      resourceName: options?.resourceName,\n      changes: options?.changes,\n      severity: options?.severity || 'info',\n      status: options?.status || 'success',\n      errorMessage: options?.errorMessage,\n      ipAddress: options?.ipAddress,\n      userAgent: options?.userAgent,\n      metadata: options?.metadata,\n      timestamp: Date.now(),\n      duration: options?.duration,\n    };\n\n    this.logs.push(log);\n    this.updateStatistics(log);\n    this.indexLog(log);\n\n    // Keep only recent logs\n    if (this.logs.length > this.maxLogs) {\n      this.logs = this.logs.slice(-this.maxLogs);\n    }\n\n    this.emit('audit:logged', log);\n    return log;\n  }\n\n  /**\n   * Update statistics\n   */\n  private updateStatistics(log: AuditLog): void {\n    this.statistics.totalLogs++;\n    this.statistics.logsByAction[log.action]++;\n    this.statistics.logsBySeverity[log.severity]++;\n    this.statistics.logsByUser[log.userId] = (this.statistics.logsByUser[log.userId] || 0) + 1;\n\n    if (log.severity === 'critical') {\n      this.statistics.criticalActionsCount++;\n    }\n\n    // Update success rate\n    const successCount = this.logs.filter((l) => l.status === 'success').length;\n    this.statistics.successRate = (successCount / this.logs.length) * 100;\n\n    // Update average duration\n    const logsWithDuration = this.logs.filter((l) => l.duration);\n    if (logsWithDuration.length > 0) {\n      const totalDuration = logsWithDuration.reduce((sum, l) => sum + (l.duration || 0), 0);\n      this.statistics.averageActionDuration = totalDuration / logsWithDuration.length;\n    }\n  }\n\n  /**\n   * Index log for search\n   */\n  private indexLog(log: AuditLog): void {\n    const searchTerms = [\n      log.userId,\n      log.username,\n      log.action,\n      log.resourceType,\n      log.resourceId,\n      log.resourceName,\n    ].filter(Boolean);\n\n    for (const term of searchTerms) {\n      if (!this.searchIndex.has(term)) {\n        this.searchIndex.set(term, new Set());\n      }\n      this.searchIndex.get(term)!.add(log.id);\n    }\n  }\n\n  /**\n   * Search logs\n   */\n  searchLogs(query: string): AuditLog[] {\n    const logIds = this.searchIndex.get(query);\n    if (!logIds) return [];\n\n    return Array.from(logIds)\n      .map((id) => this.logs.find((l) => l.id === id))\n      .filter(Boolean) as AuditLog[];\n  }\n\n  /**\n   * Filter logs\n   */\n  filterLogs(filter: AuditFilter, limit: number = 1000): AuditLog[] {\n    let filtered = [...this.logs];\n\n    if (filter.userId) {\n      filtered = filtered.filter((l) => l.userId === filter.userId);\n    }\n\n    if (filter.action) {\n      filtered = filtered.filter((l) => l.action === filter.action);\n    }\n\n    if (filter.resourceType) {\n      filtered = filtered.filter((l) => l.resourceType === filter.resourceType);\n    }\n\n    if (filter.severity) {\n      filtered = filtered.filter((l) => l.severity === filter.severity);\n    }\n\n    if (filter.status) {\n      filtered = filtered.filter((l) => l.status === filter.status);\n    }\n\n    if (filter.startDate) {\n      filtered = filtered.filter((l) => l.timestamp >= filter.startDate!);\n    }\n\n    if (filter.endDate) {\n      filtered = filtered.filter((l) => l.timestamp <= filter.endDate!);\n    }\n\n    if (filter.searchQuery) {\n      const query = filter.searchQuery.toLowerCase();\n      filtered = filtered.filter(\n        (l) =>\n          l.username.toLowerCase().includes(query) ||\n          l.action.toLowerCase().includes(query) ||\n          l.resourceType.toLowerCase().includes(query) ||\n          l.resourceName?.toLowerCase().includes(query)\n      );\n    }\n\n    return filtered.sort((a, b) => b.timestamp - a.timestamp).slice(0, limit);\n  }\n\n  /**\n   * Get logs by user\n   */\n  getLogsByUser(userId: string, limit: number = 100): AuditLog[] {\n    return this.logs\n      .filter((l) => l.userId === userId)\n      .sort((a, b) => b.timestamp - a.timestamp)\n      .slice(0, limit);\n  }\n\n  /**\n   * Get logs by action\n   */\n  getLogsByAction(action: AuditAction, limit: number = 100): AuditLog[] {\n    return this.logs\n      .filter((l) => l.action === action)\n      .sort((a, b) => b.timestamp - a.timestamp)\n      .slice(0, limit);\n  }\n\n  /**\n   * Get logs by resource\n   */\n  getLogsByResource(resourceType: string, resourceId: string, limit: number = 100): AuditLog[] {\n    return this.logs\n      .filter((l) => l.resourceType === resourceType && l.resourceId === resourceId)\n      .sort((a, b) => b.timestamp - a.timestamp)\n      .slice(0, limit);\n  }\n\n  /**\n   * Get critical logs\n   */\n  getCriticalLogs(limit: number = 100): AuditLog[] {\n    return this.logs\n      .filter((l) => l.severity === 'critical')\n      .sort((a, b) => b.timestamp - a.timestamp)\n      .slice(0, limit);\n  }\n\n  /**\n   * Get failed actions\n   */\n  getFailedActions(limit: number = 100): AuditLog[] {\n    return this.logs\n      .filter((l) => l.status === 'failure')\n      .sort((a, b) => b.timestamp - a.timestamp)\n      .slice(0, limit);\n  }\n\n  /**\n   * Generate audit report\n   */\n  generateReport(\n    name: string,\n    description: string,\n    filters: AuditFilter,\n    format: 'pdf' | 'csv' | 'json',\n    userId: string\n  ): AuditReport {\n    const logs = this.filterLogs(filters);\n    const stats = this.calculateStatistics(logs);\n\n    const report: AuditReport = {\n      id: `report-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,\n      name,\n      description,\n      filters,\n      format,\n      generatedAt: Date.now(),\n      generatedBy: userId,\n      logs,\n      statistics: stats,\n    };\n\n    this.reports.set(report.id, report);\n    this.emit('report:generated', report);\n\n    return report;\n  }\n\n  /**\n   * Calculate statistics for logs\n   */\n  private calculateStatistics(logs: AuditLog[]): AuditStatistics {\n    const stats: AuditStatistics = {\n      totalLogs: logs.length,\n      logsByAction: {} as Record<AuditAction, number>,\n      logsBySeverity: { info: 0, warning: 0, critical: 0 },\n      logsByUser: {},\n      successRate: 0,\n      averageActionDuration: 0,\n      criticalActionsCount: 0,\n    };\n\n    for (const log of logs) {\n      stats.logsByAction[log.action] = (stats.logsByAction[log.action] || 0) + 1;\n      stats.logsBySeverity[log.severity]++;\n      stats.logsByUser[log.userId] = (stats.logsByUser[log.userId] || 0) + 1;\n\n      if (log.severity === 'critical') {\n        stats.criticalActionsCount++;\n      }\n    }\n\n    const successCount = logs.filter((l) => l.status === 'success').length;\n    stats.successRate = logs.length > 0 ? (successCount / logs.length) * 100 : 0;\n\n    const logsWithDuration = logs.filter((l) => l.duration);\n    if (logsWithDuration.length > 0) {\n      const totalDuration = logsWithDuration.reduce((sum, l) => sum + (l.duration || 0), 0);\n      stats.averageActionDuration = totalDuration / logsWithDuration.length;\n    }\n\n    return stats;\n  }\n\n  /**\n   * Get report\n   */\n  getReport(reportId: string): AuditReport | undefined {\n    return this.reports.get(reportId);\n  }\n\n  /**\n   * List reports\n   */\n  listReports(limit: number = 50): AuditReport[] {\n    return Array.from(this.reports.values())\n      .sort((a, b) => b.generatedAt - a.generatedAt)\n      .slice(0, limit);\n  }\n\n  /**\n   * Delete report\n   */\n  deleteReport(reportId: string): boolean {\n    return this.reports.delete(reportId);\n  }\n\n  /**\n   * Export logs\n   */\n  exportLogs(logs: AuditLog[], format: 'csv' | 'json'): string {\n    if (format === 'json') {\n      return JSON.stringify(logs, null, 2);\n    }\n\n    // CSV export\n    const headers = [\n      'ID',\n      'Timestamp',\n      'User ID',\n      'Username',\n      'Action',\n      'Resource Type',\n      'Resource ID',\n      'Resource Name',\n      'Severity',\n      'Status',\n      'Duration (ms)',\n      'Error Message',\n    ];\n\n    const rows = logs.map((log) => [\n      log.id,\n      new Date(log.timestamp).toISOString(),\n      log.userId,\n      log.username,\n      log.action,\n      log.resourceType,\n      log.resourceId,\n      log.resourceName || '',\n      log.severity,\n      log.status,\n      log.duration || '',\n      log.errorMessage || '',\n    ]);\n\n    const csv = [\n      headers.map((h) => `\"${h}\"`).join(','),\n      ...rows.map((r) => r.map((v) => `\"${v}\"`).join(',')),\n    ].join('\\n');\n\n    return csv;\n  }\n\n  /**\n   * Get statistics\n   */\n  getStatistics(): AuditStatistics {\n    return { ...this.statistics };\n  }\n\n  /**\n   * Get recent logs\n   */\n  getRecentLogs(limit: number = 100): AuditLog[] {\n    return this.logs.slice(-limit).reverse();\n  }\n\n  /**\n   * Clear old logs\n   */\n  clearOldLogs(daysOld: number = 90): number {\n    const cutoffTime = Date.now() - daysOld * 24 * 60 * 60 * 1000;\n    const initialSize = this.logs.length;\n\n    this.logs = this.logs.filter((log) => log.timestamp > cutoffTime);\n\n    const removed = initialSize - this.logs.length;\n    this.emit('logs:cleared', { removed, daysOld });\n\n    return removed;\n  }\n\n  /**\n   * Get audit trail summary\n   */\n  getSummary(timeRange: 'hour' | 'day' | 'week' | 'month' = 'day'): Record<string, any> {\n    const now = Date.now();\n    const ranges: Record<string, number> = {\n      hour: 60 * 60 * 1000,\n      day: 24 * 60 * 60 * 1000,\n      week: 7 * 24 * 60 * 60 * 1000,\n      month: 30 * 24 * 60 * 60 * 1000,\n    };\n\n    const cutoff = now - ranges[timeRange];\n    const recentLogs = this.logs.filter((l) => l.timestamp > cutoff);\n\n    const summary = {\n      timeRange,\n      logsCount: recentLogs.length,\n      uniqueUsers: new Set(recentLogs.map((l) => l.userId)).size,\n      successCount: recentLogs.filter((l) => l.status === 'success').length,\n      failureCount: recentLogs.filter((l) => l.status === 'failure').length,\n      criticalCount: recentLogs.filter((l) => l.severity === 'critical').length,\n      topActions: this.getTopActions(recentLogs, 5),\n      topUsers: this.getTopUsers(recentLogs, 5),\n    };\n\n    return summary;\n  }\n\n  /**\n   * Get top actions\n   */\n  private getTopActions(logs: AuditLog[], limit: number): Array<{ action: AuditAction; count: number }> {\n    const counts: Record<AuditAction, number> = {} as any;\n\n    for (const log of logs) {\n      counts[log.action] = (counts[log.action] || 0) + 1;\n    }\n\n    return Object.entries(counts)\n      .map(([action, count]) => ({ action: action as AuditAction, count }))\n      .sort((a, b) => b.count - a.count)\n      .slice(0, limit);\n  }\n\n  /**\n   * Get top users\n   */\n  private getTopUsers(logs: AuditLog[], limit: number): Array<{ userId: string; username: string; count: number }> {\n    const counts: Record<string, { username: string; count: number }> = {};\n\n    for (const log of logs) {\n      if (!counts[log.userId]) {\n        counts[log.userId] = { username: log.username, count: 0 };\n      }\n      counts[log.userId].count++;\n    }\n\n    return Object.entries(counts)\n      .map(([userId, data]) => ({ userId, ...data }))\n      .sort((a, b) => b.count - a.count)\n      .slice(0, limit);\n  }\n}\n\nexport default AuditTrailManager;\n
